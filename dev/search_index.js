var documenterSearchIndex = {"docs":
[{"location":"#","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"I'm using the data from the dplyr tutorial. The data is in the test folder of this package.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"I created it with the following R code:","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"library(nycflights13)\nsetwd(\"C:/Users/hp/.julia/dev/LightQuery/test\")\nwrite.csv(airports, \"airports.csv\", na = \"\", row.names = FALSE)\nwrite.csv(flights, \"flights.csv\", na = \"\", row.names = FALSE)\nwrite.csv(weathers, \"weather.csv\", na = \"\", row.names = FALSE)","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Import tools from Dates, TimeZones, and Unitful.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> using LightQuery\n\njulia> using Dates: Date, DateTime, Hour\n\njulia> using TimeZones: Class, Local, TimeZone, VariableTimeZone, ZonedDateTime\n\njulia> using Unitful: °, °F, ft, hr, inch, mbar, mi, minute","category":"page"},{"location":"#Airports-cleaning-1","page":"Tutorial","title":"Airports cleaning","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use CSV.File to import the airports data.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> import CSV\n\njulia> airports_file = CSV.File(\"airports.csv\", missingstrings = [\"\", \"\\\\N\"])\nCSV.File(\"airports.csv\"):\nSize: 1458 x 8\nTables.Schema:\n :faa    String\n :name   String\n :lat    Float64\n :lon    Float64\n :alt    Int64\n :tz     Int64\n :dst    String\n :tzone  Union{Missing, String}","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"For this package, I made named_tuples to replace NamedTuples. Use @name to work with them.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Convert the schema to row_info.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> using Tables: schema\n\njulia> const Airport = row_info(schema(airports_file));","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Read the first row.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airport = Airport(first(airports_file))\n((`faa`, \"04G\"), (`name`, \"Lansdowne Airport\"), (`lat`, 41.1304722), (`lon`, -80.6195833), (`alt`, 1044), (`tz`, -5), (`dst`, \"A\"), (`tzone`, \"America/New_York\"))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"rename.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airport = @name rename(airport,\n            airport_code = :faa,\n            altitude = :alt,\n            daylight_savings = :dst,\n            latitude = :lat,\n            longitude = :lon,\n            time_zone = :tzone,\n            time_zone_offset = :tz\n        )\n((`name`, \"Lansdowne Airport\"), (`airport_code`, \"04G\"), (`altitude`, 1044), (`daylight_savings`, \"A\"), (`latitude`, 41.1304722), (`longitude`, -80.6195833), (`time_zone`, \"America/New_York\"), (`time_zone_offset`, -5))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"remove redundant data.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airport = @name remove(airport,\n            :daylight_savings,\n            :time_zone_offset\n        )\n((`name`, \"Lansdowne Airport\"), (`airport_code`, \"04G\"), (`altitude`, 1044), (`latitude`, 41.1304722), (`longitude`, -80.6195833), (`time_zone`, \"America/New_York\"))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Add units with transform.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airport = @name transform(airport,\n            altitude = airport.altitude * ft,\n            latitude = airport.latitude * °,\n            longitude = airport.longitude * °\n        )\n((`name`, \"Lansdowne Airport\"), (`airport_code`, \"04G\"), (`time_zone`, \"America/New_York\"), (`altitude`, 1044 ft), (`latitude`, 41.1304722°), (`longitude`, -80.6195833°))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Get a true TimeZone. Use @if_known to handle missing data. Note the data contains some LEGACY timezones. Use a type annotation: TimeZone is unstable without it.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> get_time_zone(time_zone) = TimeZone(\n            (@if_known time_zone),\n            Class(:STANDARD) | Class(:LEGACY)\n        )::VariableTimeZone;\n\njulia> @name get_time_zone(airport.time_zone)\nAmerica/New_York (UTC-5/UTC-4)","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use the chaining macro @> to chain calls together.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> function get_airport(row)\n            @name @> Airport(row) |>\n            rename(_,\n                airport_code = :faa,\n                altitude = :alt,\n                daylight_savings = :dst,\n                latitude = :lat,\n                longitude = :lon,\n                time_zone = :tzone,\n                time_zone_offset = :tz\n            ) |>\n            remove(_,\n                :daylight_savings,\n                :time_zone_offset,\n            ) |>\n            transform(_,\n                altitude = _.altitude * ft,\n                latitude = _.latitude * °,\n                longitude = _.longitude * °,\n                time_zone = get_time_zone(_.time_zone)\n            )\n        end;\n\njulia> get_airport(first(airports_file))\n((`name`, \"Lansdowne Airport\"), (`airport_code`, \"04G\"), (`altitude`, 1044 ft), (`latitude`, 41.1304722°), (`longitude`, -80.6195833°), (`time_zone`, tz\"America/New_York\"))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"over each row.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airports = over(airports_file, get_airport);\n\njulia> first(airports)\n((`name`, \"Lansdowne Airport\"), (`airport_code`, \"04G\"), (`altitude`, 1044 ft), (`latitude`, 41.1304722°), (`longitude`, -80.6195833°), (`time_zone`, tz\"America/New_York\"))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Call make_columns then to_rows to store the data column-wise but view it row-wise. Peek to view.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airports = to_rows(make_columns(airports));\n\njulia> Peek(airports)\nShowing 4 of 1458 rows\n|                        `name` | `airport_code` | `altitude` |  `latitude` |  `longitude` |                    `time_zone` |\n| -----------------------------:| --------------:| ----------:| -----------:| ------------:| ------------------------------:|\n|             Lansdowne Airport |            04G |    1044 ft | 41.1304722° | -80.6195833° | America/New_York (UTC-5/UTC-4) |\n| Moton Field Municipal Airport |            06A |     264 ft | 32.4605722° | -85.6800278° |  America/Chicago (UTC-6/UTC-5) |\n|           Schaumburg Regional |            06C |     801 ft | 41.9893408° | -88.1012428° |  America/Chicago (UTC-6/UTC-5) |\n|               Randall Airport |            06N |     523 ft |  41.431912° | -74.3915611° | America/New_York (UTC-5/UTC-4) |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"index airports by code.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> const indexed_airports = @name index(airports, :airport_code);\n\njulia> indexed_airports[\"JFK\"]\n((`name`, \"John F Kennedy Intl\"), (`airport_code`, \"JFK\"), (`altitude`, 13 ft), (`latitude`, 40.639751°), (`longitude`, -73.778925°), (`time_zone`, tz\"America/New_York\"))","category":"page"},{"location":"#Flights-cleaning-1","page":"Tutorial","title":"Flights cleaning","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use CSV.File to import the flights data.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> flights_file = CSV.File(\"flights.csv\")\nCSV.File(\"flights.csv\"):\nSize: 336776 x 19\nTables.Schema:\n :year            Int64\n :month           Int64\n :day             Int64\n :dep_time        Union{Missing, Int64}\n :sched_dep_time  Int64\n :dep_delay       Union{Missing, Int64}\n :arr_time        Union{Missing, Int64}\n :sched_arr_time  Int64\n :arr_delay       Union{Missing, Int64}\n :carrier         String\n :flight          Int64\n :tailnum         Union{Missing, String}\n :origin          String\n :dest            String\n :air_time        Union{Missing, Int64}\n :distance        Int64\n :hour            Int64\n :minute          Int64\n :time_hour       String","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Get the first flight, rename, remove, and transform to add units.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> const Flight = row_info(schema(flights_file));\n\njulia> flight =\n        @name @> flights_file |>\n        first |>\n        Flight |>\n        rename(_,\n            arrival_delay = :arr_delay,\n            arrival_time = :arr_time,\n            departure_delay = :dep_delay,\n            departure_time = :dep_time,\n            destination = :dest,\n            scheduled_arrival_time = :sched_arr_time,\n            scheduled_departure_time = :sched_dep_time,\n            tail_number = :tailnum\n        ) |>\n        remove(_,\n            :arrival_time,\n            :departure_time,\n            :hour,\n            :minute,\n            :time_hour\n        ) |>\n        transform(_,\n            air_time = _.air_time * minute,\n            arrival_delay = _.arrival_delay * minute,\n            departure_delay = _.departure_delay * minute,\n            distance = _.distance * mi\n        )\n((`year`, 2013), (`month`, 1), (`day`, 1), (`carrier`, \"UA\"), (`flight`, 1545), (`origin`, \"EWR\"), (`destination`, \"IAH\"), (`scheduled_arrival_time`, 819), (`scheduled_departure_time`, 515), (`tail_number`, \"N14228\"), (`air_time`, 227 minute), (`arrival_delay`, 11 minute), (`departure_delay`, 2 minute), (`distance`, 1400 mi))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Find the time_zone of the airport the flight departed from. Use @if_known to handle missing data.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> airport = @if_known @name get(indexed_airports, flight.origin, missing)\n((`name`, \"Newark Liberty Intl\"), (`airport_code`, \"EWR\"), (`altitude`, 18 ft), (`latitude`, 40.6925°), (`longitude`, -74.168667°), (`time_zone`, tz\"America/New_York\"))\n\njulia> time_zone = @if_known @name airport.time_zone\nAmerica/New_York (UTC-5/UTC-4)","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use divrem(_, 100) to split the scheduled_departure_time.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> @name divrem(flight.scheduled_departure_time, 100)\n(5, 15)","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Create a ZonedDateTime.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> @name ZonedDateTime(\n            flight.year,\n            flight.month,\n            flight.day,\n            divrem(flight.scheduled_departure_time, 100)...,\n            time_zone\n        )\n2013-01-01T05:15:00-05:00","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"All together:","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> get_time(indexed_airports, flight, airport, time) =\n            @name ZonedDateTime(\n                flight.year,\n                flight.month,\n                flight.day,\n                divrem(time, 100)...,\n                @if_known (\n                    @if_known get(indexed_airports, airport, missing)\n                ).time_zone\n            );\n\njulia> @name get_time(\n            indexed_airports,\n            flight,\n            flight.origin,\n            flight.scheduled_departure_time\n        )\n2013-01-01T05:15:00-05:00","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"We can do the same for the scheduled_arrival_time.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> arrival = @name get_time(\n            indexed_airports,\n            flight,\n            flight.destination,\n            flight.scheduled_arrival_time\n        )\n2013-01-01T08:19:00-06:00","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"All together.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> function get_flight(indexed_airports, row)\n            @name @> row |>\n            Flight |>\n            rename(_,\n                arrival_delay = :arr_delay,\n                arrival_time = :arr_time,\n                departure_delay = :dep_delay,\n                departure_time = :dep_time,\n                destination = :dest,\n                scheduled_arrival_time = :sched_arr_time,\n                scheduled_departure_time = :sched_dep_time,\n                tail_number = :tailnum\n            ) |>\n            remove(_,\n                :arrival_time,\n                :departure_time,\n                :hour,\n                :minute,\n                :time_hour\n            ) |>\n            transform(_,\n                air_time = _.air_time * minute,\n                distance = _.distance * mi,\n                departure_delay = _.departure_delay * minute,\n                arrival_delay = _.arrival_delay * minute,\n                scheduled_departure_time =\n                    get_time(indexed_airports, _, _.origin, _.scheduled_departure_time),\n                scheduled_arrival_time =\n                    get_time(indexed_airports, _, _.destination, _.scheduled_arrival_time)\n            ) |>\n            remove(_,\n                :year,\n                :month,\n                :day\n            )\n        end;\n\njulia> get_flight(indexed_airports, first(flights_file))\n((`carrier`, \"UA\"), (`flight`, 1545), (`origin`, \"EWR\"), (`destination`, \"IAH\"), (`tail_number`, \"N14228\"), (`air_time`, 227 minute), (`distance`, 1400 mi), (`departure_delay`, 2 minute), (`arrival_delay`, 11 minute), (`scheduled_departure_time`, ZonedDateTime(2013, 1, 1, 5, 15, tz\"America/New_York\")), (`scheduled_arrival_time`, ZonedDateTime(2013, 1, 1, 8, 19, tz\"America/Chicago\")))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"over each row. Use @_ to create an anonymous function.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> flights =\n        @> flights_file |>\n        over(_, @_ get_flight(indexed_airports, _));\n\njulia> flights =\n        flights |>\n        make_columns |>\n        to_rows;\n\njulia> Peek(flights)\nShowing 4 of 336776 rows\n| `carrier` | `flight` | `origin` | `destination` | `tail_number` | `air_time` | `distance` | `departure_delay` | `arrival_delay` | `scheduled_departure_time` |  `scheduled_arrival_time` |\n| ---------:| --------:| --------:| -------------:| -------------:| ----------:| ----------:| -----------------:| ---------------:| --------------------------:| -------------------------:|\n|        UA |     1545 |      EWR |           IAH |        N14228 | 227 minute |    1400 mi |          2 minute |       11 minute |  2013-01-01T05:15:00-05:00 | 2013-01-01T08:19:00-06:00 |\n|        UA |     1714 |      LGA |           IAH |        N24211 | 227 minute |    1416 mi |          4 minute |       20 minute |  2013-01-01T05:29:00-05:00 | 2013-01-01T08:30:00-06:00 |\n|        AA |     1141 |      JFK |           MIA |        N619AA | 160 minute |    1089 mi |          2 minute |       33 minute |  2013-01-01T05:40:00-05:00 | 2013-01-01T08:50:00-05:00 |\n|        B6 |      725 |      JFK |           BQN |        N804JB | 183 minute |    1576 mi |         -1 minute |      -18 minute |  2013-01-01T05:45:00-05:00 |                   missing |","category":"page"},{"location":"#Flights-validation-1","page":"Tutorial","title":"Flights validation","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Theoretically, the distances between two airports is always the same. Make sure this is the case in our data. First, order by origin, destination, and distance. Then Group By the same variables.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> paths_grouped =\n        @name @> flights |>\n        order(_, (:origin, :destination, :distance)) |>\n        Group(By(_, (:origin, :destination, :distance)));","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Each Group contains a key and value","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> path = first(paths_grouped);\n\njulia> key(path)\n((`origin`, \"EWR\"), (`destination`, \"ALB\"), (`distance`, 143 mi))\n\njulia> value(path) |> Peek\nShowing 4 of 439 rows\n| `carrier` | `flight` | `origin` | `destination` | `tail_number` | `air_time` | `distance` | `departure_delay` | `arrival_delay` | `scheduled_departure_time` |  `scheduled_arrival_time` |\n| ---------:| --------:| --------:| -------------:| -------------:| ----------:| ----------:| -----------------:| ---------------:| --------------------------:| -------------------------:|\n|        EV |     4112 |      EWR |           ALB |        N13538 |  33 minute |     143 mi |         -2 minute |      -10 minute |  2013-01-01T13:17:00-05:00 | 2013-01-01T14:23:00-05:00 |\n|        EV |     3260 |      EWR |           ALB |        N19554 |  36 minute |     143 mi |         34 minute |       40 minute |  2013-01-01T16:21:00-05:00 | 2013-01-01T17:24:00-05:00 |\n|        EV |     4170 |      EWR |           ALB |        N12540 |  31 minute |     143 mi |         52 minute |       44 minute |  2013-01-01T20:04:00-05:00 | 2013-01-01T21:12:00-05:00 |\n|        EV |     4316 |      EWR |           ALB |        N14153 |  33 minute |     143 mi |          5 minute |      -14 minute |  2013-01-02T13:27:00-05:00 | 2013-01-02T14:33:00-05:00 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"All we need is the key.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> paths =\n        @> paths_grouped |>\n        over(_, key) |>\n        make_columns |>\n        to_rows;\n\njulia> Peek(paths)\nShowing 4 of 226 rows\n| `origin` | `destination` | `distance` |\n| --------:| -------------:| ----------:|\n|      EWR |           ALB |     143 mi |\n|      EWR |           ANC |    3370 mi |\n|      EWR |           ATL |     746 mi |\n|      EWR |           AUS |    1504 mi |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Find the number of distinct distances.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> distinct_distances =\n        @name @> paths |>\n        Group(By(_, (:origin, :destination))) |>\n        over(_, @_ transform(key(_),\n            number = length(value(_))\n        ));\n\njulia> Peek(distinct_distances)\nShowing at most 4 rows\n| `origin` | `destination` | `number` |\n| --------:| -------------:| --------:|\n|      EWR |           ALB |        1 |\n|      EWR |           ANC |        1 |\n|      EWR |           ATL |        1 |\n|      EWR |           AUS |        1 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"See when there are multiple distances for the same path:","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> @name @> distinct_distances |>\n        when(_, @_ _.number != 1) |>\n        Peek\nShowing at most 4 rows\n| `origin` | `destination` | `number` |\n| --------:| -------------:| --------:|\n|      EWR |           EGE |        2 |\n|      JFK |           EGE |        2 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Peek at flights going to \"EGE\" using when.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> @name @> flights |>\n        when(_, @_ _.destination == \"EGE\") |>\n        Peek\nShowing at most 4 rows\n| `carrier` | `flight` | `origin` | `destination` | `tail_number` | `air_time` | `distance` | `departure_delay` | `arrival_delay` | `scheduled_departure_time` |  `scheduled_arrival_time` |\n| ---------:| --------:| --------:| -------------:| -------------:| ----------:| ----------:| -----------------:| ---------------:| --------------------------:| -------------------------:|\n|        UA |     1597 |      EWR |           EGE |        N27733 | 287 minute |    1726 mi |         -2 minute |       13 minute |  2013-01-01T09:28:00-05:00 | 2013-01-01T12:20:00-07:00 |\n|        AA |      575 |      JFK |           EGE |        N5DRAA | 280 minute |    1747 mi |         -5 minute |        3 minute |  2013-01-01T17:00:00-05:00 | 2013-01-01T19:50:00-07:00 |\n|        UA |     1597 |      EWR |           EGE |        N24702 | 261 minute |    1726 mi |          1 minute |        3 minute |  2013-01-02T09:28:00-05:00 | 2013-01-02T12:20:00-07:00 |\n|        AA |      575 |      JFK |           EGE |        N631AA | 260 minute |    1747 mi |          5 minute |       16 minute |  2013-01-02T17:00:00-05:00 | 2013-01-02T19:50:00-07:00 |","category":"page"},{"location":"#Weather-cleaning-1","page":"Tutorial","title":"Weather cleaning","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Import weather data. Get the first row, rename, remove, and transform to add units.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> weathers_file = CSV.File(\"weather.csv\")\nCSV.File(\"weather.csv\"):\nSize: 26115 x 15\nTables.Schema:\n :origin      String\n :year        Int64\n :month       Int64\n :day         Int64\n :hour        Int64\n :temp        Union{Missing, Float64}\n :dewp        Union{Missing, Float64}\n :humid       Union{Missing, Float64}\n :wind_dir    Union{Missing, Int64}\n :wind_speed  Union{Missing, Float64}\n :wind_gust   Union{Missing, Float64}\n :precip      Float64\n :pressure    Union{Missing, Float64}\n :visib       Float64\n :time_hour   String\n\njulia> const Weather = row_info(schema(weathers_file));\n\njulia> function get_weather(indexed_airports, row)\n            @name @> row |>\n            Weather |>\n            rename(_,\n                airport_code = :origin,\n                dew_point = :dewp,\n                humidity = :humid,\n                precipitation = :precip,\n                temperature = :temp,\n                visibility = :visib,\n                wind_direction = :wind_dir\n            ) |>\n            transform(_,\n                dew_point = _.dew_point * °F,\n                humidity = _.humidity / 100,\n                precipitation = _.precipitation * inch,\n                pressure = _.pressure * mbar,\n                temperature = _.temperature * °F,\n                visibility = _.visibility * mi,\n                wind_direction = _.wind_direction * °,\n                wind_gust = _.wind_gust * mi / hr,\n                wind_speed = _.wind_speed * mi / hr,\n                date_time = ZonedDateTime(\n                    _.year,\n                    _.month,\n                    _.day,\n                    _.hour,\n                    indexed_airports[_.airport_code].time_zone,\n                    1\n                )\n            ) |>\n            remove(_,\n                :year,\n                :month,\n                :day,\n                :hour\n            )\n        end;\n\njulia> weathers =\n        @> weathers_file |>\n        over(_, @_ get_weather(indexed_airports, _));\n\njulia> Peek(weathers)\nShowing 4 of 26115 rows\n|         `time_hour` | `airport_code` | `dew_point` |         `humidity` | `precipitation` |  `pressure` | `temperature` | `visibility` | `wind_direction` | `wind_gust` |      `wind_speed` |               `date_time` |\n| -------------------:| --------------:| -----------:| ------------------:| ---------------:| -----------:| -------------:| ------------:| ----------------:| -----------:| -----------------:| -------------------------:|\n| 2013-01-01 01:00:00 |            EWR |    26.06 °F |             0.5937 |        0.0 inch | 1012.0 mbar |      39.02 °F |      10.0 mi |             270° |     missing | 10.35702 mi hr^-1 | 2013-01-01T01:00:00-05:00 |\n| 2013-01-01 02:00:00 |            EWR |    26.96 °F | 0.6163000000000001 |        0.0 inch | 1012.3 mbar |      39.02 °F |      10.0 mi |             250° |     missing |  8.05546 mi hr^-1 | 2013-01-01T02:00:00-05:00 |\n| 2013-01-01 03:00:00 |            EWR |    28.04 °F | 0.6443000000000001 |        0.0 inch | 1012.5 mbar |      39.02 °F |      10.0 mi |             240° |     missing |  11.5078 mi hr^-1 | 2013-01-01T03:00:00-05:00 |\n| 2013-01-01 04:00:00 |            EWR |    28.04 °F |             0.6221 |        0.0 inch | 1012.2 mbar |      39.92 °F |      10.0 mi |             250° |     missing | 12.65858 mi hr^-1 | 2013-01-01T04:00:00-05:00 |","category":"page"},{"location":"#Joining-flights-and-weather-1","page":"Tutorial","title":"Joining flights and weather","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"I know that the weather data is already sorted by airport_code and hour.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"To mix it with flights, order and Group flights By matching variables. Only use data when the departure_delay is present.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> grouped_flights =\n        @name @> flights |>\n        when(_, @_ _.departure_delay !== missing) |>\n        order(_, (:origin, :scheduled_departure_time)) |>\n        Group(By(_, @_ (_.origin, floor(_.scheduled_departure_time, Hour))));\n\njulia> key(first(grouped_flights))\n(\"EWR\", ZonedDateTime(2013, 1, 1, 5, tz\"America/New_York\"))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Now mix.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> weathers_to_flights = @name @> mix(:inner,\n            By(weathers, @_ (_.airport_code, _.date_time)),\n            By(grouped_flights, key)\n        );","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Look at the first match.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> a_match = first(weathers_to_flights);\n\njulia> weather, (flights_key, flights_value) = a_match;\n\njulia> weather\n((`time_hour`, \"2013-01-01 05:00:00\"), (`airport_code`, \"EWR\"), (`dew_point`, 28.04 °F), (`humidity`, 0.6443000000000001), (`precipitation`, 0.0 inch), (`pressure`, 1011.9 mbar), (`temperature`, 39.02 °F), (`visibility`, 10.0 mi), (`wind_direction`, 260°), (`wind_gust`, missing), (`wind_speed`, 12.65858 mi hr^-1), (`date_time`, ZonedDateTime(2013, 1, 1, 5, tz\"America/New_York\")))\n\njulia> flights_key\n(\"EWR\", ZonedDateTime(2013, 1, 1, 5, tz\"America/New_York\"))\n\njulia> Peek(flights_value)\n| `carrier` | `flight` | `origin` | `destination` | `tail_number` | `air_time` | `distance` | `departure_delay` | `arrival_delay` | `scheduled_departure_time` |  `scheduled_arrival_time` |\n| ---------:| --------:| --------:| -------------:| -------------:| ----------:| ----------:| -----------------:| ---------------:| --------------------------:| -------------------------:|\n|        UA |     1545 |      EWR |           IAH |        N14228 | 227 minute |    1400 mi |          2 minute |       11 minute |  2013-01-01T05:15:00-05:00 | 2013-01-01T08:19:00-06:00 |\n|        UA |     1696 |      EWR |           ORD |        N39463 | 150 minute |     719 mi |         -4 minute |       12 minute |  2013-01-01T05:58:00-05:00 | 2013-01-01T07:28:00-06:00 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"We're interested in visibility and departure_delay.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> visibility = @name weather.visibility\n10.0 mi\n\njulia> @name over(flights_value, @_ (\n            visibility = visibility,\n            departure_delay = _.departure_delay\n        )) |>\n        Peek\n| `visibility` | `departure_delay` |\n| ------------:| -----------------:|\n|      10.0 mi |          2 minute |\n|      10.0 mi |         -4 minute |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"All together.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> function interested_in(a_match)\n            weather, (flights_key, flights_value) = a_match\n            visibility = @name weather.visibility\n            @name over(flights_value, @_ (\n                visibility = visibility,\n                departure_delay = _.departure_delay\n            ))\n        end;\n\njulia> Peek(interested_in(a_match))\n| `visibility` | `departure_delay` |\n| ------------:| -----------------:|\n|      10.0 mi |          2 minute |\n|      10.0 mi |         -4 minute |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use flatten to unnest data (exported from Base).","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> data =\n        @name @> weathers_to_flights |>\n        over(_, interested_in) |>\n        flatten |>\n        make_columns |>\n        to_rows;\n\njulia> Peek(data)\nShowing 4 of 326993 rows\n| `visibility` | `departure_delay` |\n| ------------:| -----------------:|\n|      10.0 mi |          2 minute |\n|      10.0 mi |         -4 minute |\n|      10.0 mi |         -5 minute |\n|      10.0 mi |         -2 minute |","category":"page"},{"location":"#Visibility-vs.-departure-delay-1","page":"Tutorial","title":"Visibility vs. departure delay","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"How does visibility affect departure_delay? Group by visibility.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> by_visibility =\n        @name @> data |>\n        order(_, :visibility) |>\n        Group(By(_, :visibility));\n\njulia> visibility_group = first(by_visibility);\n\njulia> key(visibility_group)\n0.0 mi\n\njulia> value(visibility_group) |> Peek\nShowing 4 of 87 rows\n| `visibility` | `departure_delay` |\n| ------------:| -----------------:|\n|       0.0 mi |         -5 minute |\n|       0.0 mi |         -1 minute |\n|       0.0 mi |         -8 minute |\n|       0.0 mi |         -7 minute |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Calculate the mean departure_delay. Use to_columns to lazily view columns.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> using Statistics: mean\n\njulia> @name @> visibility_group |>\n        value |>\n        to_columns |>\n        _.departure_delay |>\n        mean\n32.252873563218394 minute","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"For each group.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> get_mean_departure_delay(visibility_group) = @name (\n            visibility = key(visibility_group),\n            mean_departure_delay =\n                (@> visibility_group |>\n                value |>\n                to_columns |>\n                _.departure_delay |>\n                mean),\n            count = length(value(visibility_group))\n        );\n\njulia> @> by_visibility |>\n            over(_, get_mean_departure_delay) |>\n            Peek(_, 20)\nShowing at most 20 rows\n| `visibility` |    `mean_departure_delay` | `count` |\n| ------------:| -------------------------:| -------:|\n|       0.0 mi | 32.252873563218394 minute |      87 |\n|      0.06 mi |               22.2 minute |      85 |\n|      0.12 mi |  50.69975186104218 minute |     403 |\n|      0.25 mi | 20.481110254433307 minute |    1297 |\n|       0.5 mi |   32.5890826383624 minute |    1319 |\n|      0.75 mi |  30.06759906759907 minute |     429 |\n|       1.0 mi |  32.24348473566642 minute |    1343 |\n|      1.25 mi | 53.187845303867405 minute |     181 |\n|       1.5 mi |  25.90661478599222 minute |    1542 |\n|      1.75 mi | 43.333333333333336 minute |     132 |\n|       2.0 mi | 22.701923076923077 minute |    2912 |\n|       2.5 mi |  21.18074398249453 minute |    2285 |\n|       3.0 mi |   21.2113218731476 minute |    3374 |\n|       4.0 mi |  19.48311444652908 minute |    2132 |\n|       5.0 mi |  21.10387902695595 minute |    4563 |\n|       6.0 mi | 19.807032301480483 minute |    5944 |\n|       7.0 mi | 19.208963745361118 minute |    7006 |\n|       8.0 mi |  19.98660103910309 minute |    7314 |\n|       9.0 mi | 18.762949476558944 minute |   10985 |\n|      10.0 mi | 10.951549367828692 minute |  273660 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"This data suggests that low visibility levels lead to larger departure delays, on average.","category":"page"},{"location":"#Reshaping-1","page":"Tutorial","title":"Reshaping","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"For this section, I will use data from the Global Historical Climatology Network. I got this idea from the tidyr tutorial.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> file = open(\"climate.txt\");\n\njulia> line = readline(file)\n\"ACW00011604194901TMAX  289  X  289  X  283  X  283  X  289  X  289  X  278  X  267  X  272  X  278  X  267  X  278  X  267  X  267  X  278  X  267  X  267  X  272  X  272  X  272  X  278  X  272  X  267  X  267  X  267  X  278  X  272  X  272  X  272  X  272  X  272  X\"\n\njulia> close(file)","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Parse the first chunk.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> month_variable = @name (\n            year = parse(Int, SubString(line, 12, 15)),\n            month = parse(Int, SubString(line, 16, 17)),\n            variable = Symbol(SubString(line, 18, 21))\n        )\n((`year`, 1949), (`month`, 1), (`variable`, :TMAX))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Parse a day. missing is represented by -9999.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> function get_day(line, day)\n            start = 14 + 8 * day\n            value = parse(Int, line[start:start + 4])\n            @name (day = day, value =\n                if value == -9999\n                    missing\n                else\n                    value\n                end\n            )\n        end;\n\njulia> get_day(line, 1)\n((`day`, 1), (`value`, 289))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"over each day.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> days = @> over(1:31, @_ (\n            month_variable...,\n            get_day(line, _)...\n        ));\n\njulia> first(days)\n((`year`, 1949), (`month`, 1), (`variable`, :TMAX), (`day`, 1), (`value`, 289))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use when to remove missing data;","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> days = @name when(days, @_ _.value !== missing);\n\njulia> first(days)\n((`year`, 1949), (`month`, 1), (`variable`, :TMAX), (`day`, 1), (`value`, 289))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Use transform and remove to create a Date.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> get_date(day) =\n        @name @> day |>\n        transform(_, date = Date(_.year, _.month, _.day)) |>\n        remove(_, :year, :month, :day);\n\njulia> get_date(first(days))\n((`variable`, :TMAX), (`value`, 289), (`date`, 1949-01-01))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"All together.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> function get_month_variable(line)\n            month_variable = @name (\n                year = parse(Int, SubString(line, 12, 15)),\n                month = parse(Int, SubString(line, 16, 17)),\n                variable = Symbol(SubString(line, 18, 21))\n            )\n            @name @> over(1:31, @_ (\n                month_variable...,\n                get_day(line, _)...\n            )) |>\n            when(_, @_ _.value !== missing) |>\n            over(_, get_date)\n        end;\n\njulia> first(get_month_variable(line))\n((`variable`, :TMAX), (`value`, 289), (`date`, 1949-01-01))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"over each line. Use flatten to unnest data.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> climate_data =\n        @> eachline(\"climate.txt\") |>\n        over(_, get_month_variable) |>\n        flatten |>\n        make_columns |>\n        to_rows;\n\njulia> Peek(climate_data)\nShowing 4 of 1231 rows\n| `variable` | `value` |     `date` |\n| ----------:| -------:| ----------:|\n|      :TMAX |     289 | 1949-01-01 |\n|      :TMAX |     289 | 1949-01-02 |\n|      :TMAX |     283 | 1949-01-03 |\n|      :TMAX |     283 | 1949-01-04 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Sort and group by date.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> by_date =\n        @name @> climate_data |>\n        order(_, :date) |>\n        Group(By(_, :date));\n\njulia> day_variables = first(by_date);\n\njulia> key(day_variables)\n1949-01-01\n\njulia> value(day_variables) |> Peek\nShowing 4 of 5 rows\n| `variable` | `value` |     `date` |\n| ----------:| -------:| ----------:|\n|      :TMAX |     289 | 1949-01-01 |\n|      :TMIN |     217 | 1949-01-01 |\n|      :PRCP |       0 | 1949-01-01 |\n|      :SNOW |       0 | 1949-01-01 |","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"over each variable. Use Name to make a Name. This is unavoidably type-unstable.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> spread_variables(day_variables) = @name (\n            date = key(day_variables),\n            over(\n                value(day_variables),\n                @_ (Name(_.variable), _.value)\n            )...\n        );\n\njulia> spread_variables(day_variables)\n((`date`, 1949-01-01), (`TMAX`, 289), (`TMIN`, 217), (`PRCP`, 0), (`SNOW`, 0), (`SNWD`, 0))","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"over each day.","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"julia> @> by_date |>\n        over(_, spread_variables) |>\n        Peek\nShowing at most 4 rows\n|  `WT16` |     `date` | `TMAX` | `TMIN` | `PRCP` | `SNOW` | `SNWD` |\n| -------:| ----------:| ------:| ------:| ------:| ------:| ------:|\n| missing | 1949-01-01 |    289 |    217 |      0 |      0 |      0 |\n|       1 | 1949-01-02 |    289 |    228 |     30 |      0 |      0 |\n| missing | 1949-01-03 |    283 |    222 |      0 |      0 |      0 |\n|       1 | 1949-01-04 |    283 |    233 |      0 |      0 |      0 |","category":"page"},{"location":"#Interface-1","page":"Tutorial","title":"Interface","text":"","category":"section"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Modules = [LightQuery]","category":"page"},{"location":"#","page":"Tutorial","title":"Tutorial","text":"Modules = [LightQuery]","category":"page"},{"location":"#LightQuery.Apply","page":"Tutorial","title":"LightQuery.Apply","text":"struct Apply{Names}\n\nApply Names to unnamed values.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @name @inferred Apply((:a, :b, :c, :d, :e, :f))((1, 1.0, 1, 1.0, 1, 1.0))\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"#LightQuery.By","page":"Tutorial","title":"LightQuery.By","text":"By(sorted, key_function)\n\nMark that sorted has been pre-sorted by key_function. Use with Group, or mix.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred By([1, -2], abs)\nBy{Array{Int64,1},typeof(abs)}([1, -2], abs)\n\n\n\n\n\n","category":"type"},{"location":"#LightQuery.Enumerate","page":"Tutorial","title":"LightQuery.Enumerate","text":"Enumerate{Unenumerated}\n\nRelies on the fact that iteration states can be converted to indices; thus, you might have to define LightQuery.state_to_index for unrecognized types. \"Sees through\" some iterators like when.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred collect(Enumerate(when([4, 3, 2, 1], iseven)))\n2-element Array{Tuple{Int64,Int64},1}:\n (1, 4)\n (3, 2)\n\n\n\n\n\n","category":"type"},{"location":"#LightQuery.Group-Tuple{By}","page":"Tutorial","title":"LightQuery.Group","text":"Group(ungrouped::By)\n\nGroup consecutive keys in ungrouped. Requires a presorted object (see By). Relies on Enumerate.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred collect(Group(By([1, -1, -2, 2, 3, -3], abs)))\n3-element Array{Tuple{Int64,SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true}},1}:\n (1, [1, -1])\n (2, [-2, 2])\n (3, [3, -3])\n\njulia> @inferred collect(Group(By(Int[], abs)))\n0-element Array{Tuple{Int64,SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true}},1}\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.Name-Tuple{Any}","page":"Tutorial","title":"LightQuery.Name","text":"Name(name)\n\nCreate a typed Name. Inverse of unname\n\njulia> using LightQuery\n\njulia> Name(:a)\n`a`\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.Peek-Tuple{Any}","page":"Tutorial","title":"LightQuery.Peek","text":"Peek(rows, maximum_length = 4)\n\nPeek an iterator which returns named tuples. Will show no more than maximum_length rows.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @name @inferred Peek(to_rows((a = 1:5, b = 5:-1:1)))\nShowing 4 of 5 rows\n| `a` | `b` |\n| ---:| ---:|\n|   1 |   5 |\n|   2 |   4 |\n|   3 |   3 |\n|   4 |   2 |\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.backwards-Tuple{Any}","page":"Tutorial","title":"LightQuery.backwards","text":"struct Backwards{Increasing}\n\nReverse sorting order.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred order([1, -2], x -> backwards(abs(x)))\n2-element view(::Array{Int64,1}, [2, 1]) with eltype Int64:\n -2\n  1\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.distinct","page":"Tutorial","title":"LightQuery.distinct","text":"distinct(repeated, key_function = identity)\n\nGeneralized version of unique.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred distinct([1, 2, missing, missing, 2, 1])\n3-element view(::Array{Union{Missing, Int64},1}, [1, 2, 3]) with eltype Union{Missing, Int64}:\n 1\n 2\n  missing\n\n\n\n\n\n","category":"function"},{"location":"#LightQuery.gather-Tuple{Any,Vararg{Any,N} where N}","page":"Tutorial","title":"LightQuery.gather","text":"gather(data, new_name_old_names...)\n\nFor each new_name, old_names pair in new_name_old_names, gather the old_names into a single new_name. Inverse of spread.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> data = @name (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\njulia> @name @inferred gather(data, g = (:b, :e), h = (:c, :f))\n((`a`, 1), (`d`, 1.0), (`g`, ((`b`, 1.0), (`e`, 1))), (`h`, ((`c`, 1), (`f`, 1.0))))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.if_else-Tuple{Any,Any,Any}","page":"Tutorial","title":"LightQuery.if_else","text":"if_else(switch, yes, no)\n\nifelse that you can add methods to.\n\njulia> using LightQuery\n\njulia> if_else(true, 1, 0)\n1\n\njulia> if_else(false, 1, 0)\n0\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.index-Tuple{Any,Any}","page":"Tutorial","title":"LightQuery.index","text":"index(unindexed, key_function)\n\nIndex unindexed by the results of key_function. Relies on Enumerate. Results of key_function must be unique.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred index([-2, 1], abs)\nLightQuery.Indexed{Int64,Int64,Array{Int64,1},Dict{Int64,Int64}} with 2 entries:\n  2 => -2\n  1 => 1\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.key-Tuple{Any}","page":"Tutorial","title":"LightQuery.key","text":"key(pair)\n\nThe key in a key => value pair.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred key(:a => 1)\n:a\n\njulia> @inferred key((:a, 1))\n:a\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.make_columns-Tuple{Any}","page":"Tutorial","title":"LightQuery.make_columns","text":"make_columns(rows)\n\nCollect into columns. Always eager, see to_columns for a lazy version.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> stable(x) = @name (a = x, b = x + 0.0, c = x, d = x + 0.0, e = x, f = x + 0.0);\n\njulia> @inferred make_columns(over(1:4, stable))\n((`a`, [1, 2, 3, 4]), (`b`, [1.0, 2.0, 3.0, 4.0]), (`c`, [1, 2, 3, 4]), (`d`, [1.0, 2.0, 3.0, 4.0]), (`e`, [1, 2, 3, 4]), (`f`, [1.0, 2.0, 3.0, 4.0]))\n\njulia> unstable(x) =\n            @name if x <= 2\n                (a = missing, b = string(x), d = string(x))\n            else\n                (a = x, b = missing, c = x)\n            end;\n\njulia> make_columns(over(1:4, unstable))\n((`d`, Union{Missing, String}[\"1\", \"2\", missing, missing]), (`a`, Union{Missing, Int64}[missing, missing, 3, 4]), (`b`, Union{Missing, String}[\"1\", \"2\", missing, missing]), (`c`, Union{Missing, Int64}[missing, missing, 3, 4]))\n\njulia> make_columns(when(over(1:4, unstable), row -> true))\n((`d`, Union{Missing, String}[\"1\", \"2\", missing, missing]), (`a`, Union{Missing, Int64}[missing, missing, 3, 4]), (`b`, Union{Missing, String}[\"1\", \"2\", missing, missing]), (`c`, Union{Missing, Int64}[missing, missing, 3, 4]))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.mix-Tuple{Name{:inner},Any,Any}","page":"Tutorial","title":"LightQuery.mix","text":"mix(::Name{:inner},  left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)). See By.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @name @inferred collect(mix(:inner, By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n2-element Array{Tuple{Int64,Int64},1}:\n (1, -1)\n (-6, 6)\n\njulia> @name @inferred collect(mix(:inner, By(Int[], abs), By(Int[], abs)))\n0-element Array{Tuple{Int64,Int64},1}\n\njulia> @name @inferred collect(mix(:inner, By([1], abs), By(Int[], abs)))\n0-element Array{Tuple{Int64,Int64},1}\n\njulia> @name @inferred collect(mix(:inner, By(Int[], abs), By([1], abs)))\n0-element Array{Tuple{Int64,Int64},1}\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.mix-Tuple{Name{:left},Any,Any}","page":"Tutorial","title":"LightQuery.mix","text":"mix(::Name{:left}, left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)), using missing when there is no right match.\n\njulia> using LightQuery\n\njulia> @name collect(mix(:left, By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n4-element Array{Tuple{Int64,Union{Missing, Int64}},1}:\n (1, -1)\n (-2, missing)\n (5, missing)\n (-6, 6)\n\njulia> @name collect(mix(:left, By(Int[], abs), By(Int[], abs)))\n0-element Array{Tuple{Int64,Union{Missing, Int64}},1}\n\njulia> @name collect(mix(:left, By([1], abs), By(Int[], abs)))\n1-element Array{Tuple{Int64,Union{Missing, Int64}},1}:\n (1, missing)\n\njulia> @name collect(mix(:left, By(Int[], abs), By([1], abs)))\n0-element Array{Tuple{Int64,Union{Missing, Int64}},1}\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.mix-Tuple{Name{:outer},Any,Any}","page":"Tutorial","title":"LightQuery.mix","text":"mix(::Name{:outer}, left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)), using missing when there is no left or right match.\n\njulia> using LightQuery\n\njulia> @name collect(mix(:outer, By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n6-element Array{Tuple{Union{Missing, Int64},Union{Missing, Int64}},1}:\n (1, -1)\n (-2, missing)\n (missing, 3)\n (missing, -4)\n (5, missing)\n (-6, 6)\n\njulia> @name collect(mix(:outer, By(Int[], abs), By(Int[], abs)))\n0-element Array{Tuple{Union{Missing, Int64},Union{Missing, Int64}},1}\n\njulia> @name collect(mix(:outer, By([1], abs), By(Int[], abs)))\n1-element Array{Tuple{Union{Missing, Int64},Union{Missing, Int64}},1}:\n (1, missing)\n\njulia> @name collect(mix(:outer, By(Int[], abs), By([1], abs)))\n1-element Array{Tuple{Union{Missing, Int64},Union{Missing, Int64}},1}:\n (missing, 1)\n\nAssumes left and right are both strictly sorted (no repeats). If there are repeats, Group first.\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.mix-Tuple{Name{:right},Any,Any}","page":"Tutorial","title":"LightQuery.mix","text":"mix(::Name{:right}, left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)), using missing when there is no left match.\n\njulia> using LightQuery\n\njulia> @name collect(mix(:right, By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n4-element Array{Tuple{Union{Missing, Int64},Int64},1}:\n (1, -1)\n (missing, 3)\n (missing, -4)\n (-6, 6)\n\njulia> @name collect(mix(:right, By(Int[], abs), By(Int[], abs)))\n0-element Array{Tuple{Union{Missing, Int64},Int64},1}\n\njulia> @name collect(mix(:right, By([1], abs), By(Int[], abs)))\n0-element Array{Tuple{Union{Missing, Int64},Int64},1}\n\njulia> @name collect(mix(:right, By(Int[], abs), By([1], abs)))\n1-element Array{Tuple{Union{Missing, Int64},Int64},1}:\n (missing, 1)\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.named_tuple-Tuple{Any}","page":"Tutorial","title":"LightQuery.named_tuple","text":"named_tuple(data)\n\nConvert data to a named_tuple (see @name).\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred named_tuple((a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0))\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\nFor stability working with arbitrary structs, propertynames must constant propagate.\n\njulia> struct MyType\n            a::Int\n            b::Float64\n            c::Int\n            d::Float64\n            e::Int\n            f::Float64\n        end\n\njulia> import Base: propertynames\n\njulia> @inline propertynames(::MyType) = (:a, :b, :c, :d, :e, :f);\n\njulia> @inferred named_tuple(MyType(1, 1.0, 1, 1.0, 1, 1.0))\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.order-Tuple{Any,Any}","page":"Tutorial","title":"LightQuery.order","text":"order(unordered, key_function; keywords...)\n\nGeneralized sort. keywords will be passed to sort!; see the documentation there for options. Use By to mark that an object has been sorted. Relies on Enumerate. If the results of key_function are type unstable, consider using hash ∘ key_function instead.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred order([-2, 1], abs)\n2-element view(::Array{Int64,1}, [2, 1]) with eltype Int64:\n  1\n -2\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.over-Tuple{Any,Any}","page":"Tutorial","title":"LightQuery.over","text":"over(iterator, call)\n\nLazy map with the reverse argument order.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred collect(over([1, -2, -3, 4], abs))\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.remove-Tuple{Any,Vararg{Any,N} where N}","page":"Tutorial","title":"LightQuery.remove","text":"remove(data, old_names...)\n\nRemove old_names from data.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> data = @name (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\njulia> @name @inferred remove(data, :c, :f)\n((`a`, 1), (`b`, 1.0), (`d`, 1.0), (`e`, 1))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.rename-Tuple{Any,Vararg{Any,N} where N}","page":"Tutorial","title":"LightQuery.rename","text":"rename(data, new_name_old_names...)\n\nRename data.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> data = @name (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\njulia> @name @inferred rename(data, c2 = :c, f2 = :f)\n((`a`, 1), (`b`, 1.0), (`d`, 1.0), (`e`, 1), (`c2`, 1), (`f2`, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.row_info-Union{Tuple{Schema{Names,types} where types}, Tuple{Names}} where Names","page":"Tutorial","title":"LightQuery.row_info","text":"row_info(::Tables.Schema)\n\nGet row info for the schema. Can be used as a type stable selector function.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> using CSV: File\n\njulia> using Tables: schema\n\njulia> test = File(\"test.csv\")\nCSV.File(\"test.csv\"):\nSize: 1 x 6\nTables.Schema:\n :a  Int64\n :b  Float64\n :c  Int64\n :d  Float64\n :e  Int64\n :f  Float64\n\njulia> template = @inferred row_info(schema(test))\n(LightQuery.InRow{`a`,Int64,1}(), LightQuery.InRow{`b`,Float64,2}(), LightQuery.InRow{`c`,Int64,3}(), LightQuery.InRow{`d`,Float64,4}(), LightQuery.InRow{`e`,Int64,5}(), LightQuery.InRow{`f`,Float64,6}())\n\njulia> @inferred template(first(test))\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.spread-Tuple{Any,Vararg{Any,N} where N}","page":"Tutorial","title":"LightQuery.spread","text":"spread(data, some_names...)\n\nUnnest nested named tuples. Inverse of gather.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> gathered = @name (a = 1, d = 1.0, g = (b = 1.0, e = 1), h = (c = 1, f = 1.0))\n((`a`, 1), (`d`, 1.0), (`g`, ((`b`, 1.0), (`e`, 1))), (`h`, ((`c`, 1), (`f`, 1.0))))\n\njulia> @name @inferred spread(gathered, :g, :h)\n((`a`, 1), (`d`, 1.0), (`b`, 1.0), (`e`, 1), (`c`, 1), (`f`, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.to_columns-Tuple{Base.Generator{#s15,#s14} where #s14<:Apply where #s15<:Base.Iterators.Zip}","page":"Tutorial","title":"LightQuery.to_columns","text":"to_columns(rows)\n\nInverse of to_rows. Always lazy, see make_columns for an eager version.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @name @inferred to_columns(to_rows((a = [1, 2], b = [1.0, 2.0])))\n((`a`, [1, 2]), (`b`, [1.0, 2.0]))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.to_rows-Tuple{Any}","page":"Tutorial","title":"LightQuery.to_rows","text":"to_rows(columns)\n\nIterator over rows of a table. Always lazy. Inverse of to_columns. Use Peek to view.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @name @inferred collect(to_rows((a = [1, 2], b = [1.0, 2.0])))\n2-element Array{Tuple{Tuple{Name{:a},Int64},Tuple{Name{:b},Float64}},1}:\n ((`a`, 1), (`b`, 1.0))\n ((`a`, 2), (`b`, 2.0))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.transform-Tuple{Any,Vararg{Any,N} where N}","page":"Tutorial","title":"LightQuery.transform","text":"transform(data, assignments...)\n\nMerge assignments into data, overwriting old values.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> data = @name (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\njulia> @name @inferred transform(data, c = 2.0, f = 2, g = 1, h = 1.0)\n((`a`, 1), (`b`, 1.0), (`d`, 1.0), (`e`, 1), (`c`, 2.0), (`f`, 2), (`g`, 1), (`h`, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.unname-Union{Tuple{Name{name}}, Tuple{name}} where name","page":"Tutorial","title":"LightQuery.unname","text":"unname(::Name{name}) where name\n\nInverse of Name.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred unname(Name(:a))\n:a\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.value-Tuple{Any}","page":"Tutorial","title":"LightQuery.value","text":"value(pair)\n\nThe value in a key => value pair.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred value(:a => 1)\n1\n\njulia> @inferred value((:a, 1))\n1\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.when-Tuple{Any,Any}","page":"Tutorial","title":"LightQuery.when","text":"when(iterator, call)\n\nLazy filter with the reverse argument order.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred collect(when(1:4, iseven))\n2-element Array{Int64,1}:\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"#LightQuery.@>-Tuple{Any}","page":"Tutorial","title":"LightQuery.@>","text":"macro >(body)\n\nIf body is in the form object_ |> call_, call @_ on call, and recur on object.\n\njulia> using LightQuery\n\njulia> @> 0 |> _ - 1 |> abs\n1\n\nYou can nest chains:\n\njulia> @> 1 |> (@> _ + 1 |> _ + 1)\n3\n\n\n\n\n\n","category":"macro"},{"location":"#LightQuery.@_-Tuple{Any}","page":"Tutorial","title":"LightQuery.@_","text":"macro _(body)\n\nTerser function syntax. The arguments are inside the body; the first argument is _, the second argument is __, etc.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> @inferred (@_ _ + 1)(1)\n2\n\njulia> @inferred map((@_ __ - _), (1, 2), (2, 1))\n(1, -1)\n\n\n\n\n\n","category":"macro"},{"location":"#LightQuery.@if_known-Tuple{Any}","page":"Tutorial","title":"LightQuery.@if_known","text":"if_known(something)\n\nIf something is missing, return missing, otherwise, something.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> function test(x)\n            first(@if_known(x))\n        end;\n\njulia> @inferred test((1, 2))\n1\n\njulia> @inferred test(missing)\nmissing\n\n\n\n\n\n","category":"macro"},{"location":"#LightQuery.@name-Tuple{Any}","page":"Tutorial","title":"LightQuery.@name","text":"macro name(code)\n\nSwitch to named_tuples.\n\njulia> using LightQuery\n\njulia> using Test: @inferred\n\njulia> data = @name (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n\nbased on typed Names.\n\njulia> @name :a\n`a`\n\nNames can be used as properties\n\njulia> @name @inferred data.c\n1\n\njulia> @name data.g\nERROR: BoundsError: attempt to access ((`a`, 1), (`b`, 1.0), (`c`, 1), (`d`, 1.0), (`e`, 1), (`f`, 1.0))\n[...]\n\nand selector functions.\n\njulia> @name @inferred (:c)(data)\n1\n\nMultiple names can be used as selector functions\n\njulia> @name @inferred (:c, :f)(data)\n((`c`, 1), (`f`, 1.0))\n\nYou can also convert back to NamedTuples.\n\njulia> @inferred NamedTuple(data)\n(a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n\n\n\n\n\n","category":"macro"}]
}
