var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [LightQuery]","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [LightQuery]","category":"page"},{"location":"interface/#LightQuery.Backwards","page":"Interface","title":"LightQuery.Backwards","text":"Backwards(something)\n\nReverse sorting order.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> collect(@inferred order([1, -2], Backwards))\n2-element Vector{Int64}:\n  1\n -2\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.By","page":"Interface","title":"LightQuery.By","text":"By(sorted, key_function)\n\nMark that sorted has been pre-sorted by key_function. Use with Group, and various joins.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred By([1, -2], abs)\nBy{Vector{Int64},typeof(abs)}([1, -2], abs)\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.Enumerate","page":"Interface","title":"LightQuery.Enumerate","text":"Enumerate{Unenumerated}\n\n\"Sees through\" most iterators into their parent.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred collect(Enumerate(Iterators.filter(iseven, [4, 3, 2, 1])))\n2-element Vector{Tuple{Int64,Int64}}:\n (1, 4)\n (3, 2)\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.Group-Tuple{By}","page":"Interface","title":"LightQuery.Group","text":"Group(ungrouped::By)\n\nGroup consecutive items in ungrouped.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred collect(Group(By([1, -1, -2, 2, 3, -3], abs)))\n3-element Vector{Tuple{Int64,SubArray{Int64,1,Vector{Int64},Tuple{UnitRange{Int64}},true}}}:\n (1, [1, -1])\n (2, [-2, 2])\n (3, [3, -3])\n\njulia> (@inferred collect(Group(By(Int[], abs)))) == []\ntrue\n\nRequires a presorted object (see By); order first if not.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> first_group = @> [2, 1, 2, 1] |> order(_, identity) |> Group(By(_, identity)) |> first;\n\n\njulia> key(first_group)\n1\n\njulia> collect(value(first_group))\n2-element Vector{Int64}:\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.InnerJoin","page":"Interface","title":"LightQuery.InnerJoin","text":"InnerJoin(left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)). Assumes left and right are both strictly sorted (no repeats). If there are repeats, Group first. See By.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred collect(InnerJoin(By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n2-element Vector{Tuple{Int64,Int64}}:\n (1, -1)\n (-6, 6)\n\njulia> (@inferred collect(InnerJoin(By(Int[], abs), By(Int[], abs)))) == []\ntrue\n\njulia> (@inferred collect(InnerJoin(By([1], abs), By(Int[], abs)))) == []\ntrue\n\njulia> (@inferred collect(InnerJoin(By(Int[], abs), By([1], abs)))) == []\ntrue\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.LeftJoin","page":"Interface","title":"LightQuery.LeftJoin","text":"LeftJoin(left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)), using missing when there is no right match. Assumes left and right are both strictly sorted (no repeats). If there are repeats, Group first. See By.\n\njulia> using LightQuery\n\n\njulia> collect(LeftJoin(By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n4-element Vector{Tuple{Int64,Union{Missing, Int64}}}:\n (1, -1)\n (-2, missing)\n (5, missing)\n (-6, 6)\n\njulia> collect(LeftJoin(By(Int[], abs), By(Int[], abs))) == []\ntrue\n\njulia> collect(LeftJoin(By([1], abs), By(Int[], abs)))\n1-element Vector{Tuple{Int64,Union{Missing, Int64}}}:\n (1, missing)\n\njulia> collect(LeftJoin(By(Int[], abs), By([1], abs))) == []\ntrue\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.Length","page":"Interface","title":"LightQuery.Length","text":"Length(iterator, new_length)\n\nAllow optimizations based on length.\n\njulia> using LightQuery\n\n\njulia> collect(Length(Iterators.filter(iseven, 1:4), 2))\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.Name-Tuple{Any}","page":"Interface","title":"LightQuery.Name","text":"Name(name)\n\nCreate a typed Name. Inverse of unname. See also @name_str.\n\njulia> using LightQuery\n\n\njulia> Name(:a)\nname\"a\"\n\nNames can be used as selector functions.\n\njulia> using Test: @inferred\n\n\njulia> data = (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n(a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0)\n\njulia> @inferred name\"c\"(data)\n1\n\nMultiple names can be used as selector functions\n\njulia> @inferred (name\"c\", name\"f\")(data)\n(c = 1, f = 1.0)\n\nA final use for names can be as a way to construct NamedTuples from pairs. Using Names instead of Symbols gives type stability.\n\njulia> @inferred NamedTuple((name\"a\", 1), (name\"b\", 2))\n(a = 1, b = 2)\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.OuterJoin","page":"Interface","title":"LightQuery.OuterJoin","text":"OuterJoin(left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)), using missing when there is no left or right match. Assumes left and right are both strictly sorted (no repeats). If there are repeats, Group first. See By.\n\njulia> using LightQuery\n\n\njulia> collect(OuterJoin(By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n6-element Vector{Tuple{Union{Missing, Int64},Union{Missing, Int64}}}:\n (1, -1)\n (-2, missing)\n (missing, 3)\n (missing, -4)\n (5, missing)\n (-6, 6)\n\njulia> collect(OuterJoin(By(Int[], abs), By(Int[], abs))) == []\ntrue\n\njulia> collect(OuterJoin(By([1], abs), By(Int[], abs)))\n1-element Vector{Tuple{Union{Missing, Int64},Union{Missing, Int64}}}:\n (1, missing)\n\njulia> collect(OuterJoin(By(Int[], abs), By([1], abs)))\n1-element Vector{Tuple{Union{Missing, Int64},Union{Missing, Int64}}}:\n (missing, 1)\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.Peek-Tuple{Any}","page":"Interface","title":"LightQuery.Peek","text":"Peek(rows, maximum_length = 4)\n\nPeek an iterator which returns named tuples. Will show no more than maximum_length rows.\n\njulia> using LightQuery\n\n\njulia> Peek(Rows(a = 1:5, b = 5:-1:1))\nShowing 4 of 5 rows\n|   a |   b |\n| ---:| ---:|\n|   1 |   5 |\n|   2 |   4 |\n|   3 |   3 |\n|   4 |   2 |\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.RightJoin","page":"Interface","title":"LightQuery.RightJoin","text":"RightJoin(left::By, right::By)\n\nFind all pairs where isequal(left.key_function(left.sorted), right.key_function(right.sorted)), using missing when there is no left match. Assumes left and right are both strictly sorted (no repeats). If there are repeats, Group first. See By.\n\njulia> using LightQuery\n\n\njulia> collect(RightJoin(By([1, -2, 5, -6], abs), By([-1, 3, -4, 6], abs)))\n4-element Vector{Tuple{Union{Missing, Int64},Int64}}:\n (1, -1)\n (missing, 3)\n (missing, -4)\n (-6, 6)\n\njulia> collect(RightJoin(By(Int[], abs), By(Int[], abs))) == []\ntrue\n\njulia> collect(RightJoin(By([1], abs), By(Int[], abs))) == []\ntrue\n\njulia> collect(RightJoin(By(Int[], abs), By([1], abs)))\n1-element Vector{Tuple{Union{Missing, Int64},Int64}}:\n (missing, 1)\n\n\n\n\n\n","category":"type"},{"location":"interface/#LightQuery.Rows-Tuple{}","page":"Interface","title":"LightQuery.Rows","text":"Rows(named_columns)\n\nIterator over rows of a table. Always lazy. Use Peek to view.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> lazy = @inferred Rows(a = [1, 2], b = [1.0, 2.0])\n2-element Rows{NamedTuple{(:a, :b),Tuple{Int64,Float64}},1,Tuple{Vector{Int64},Vector{Float64}},Tuple{Name{:a},Name{:b}}}:\n (a = 1, b = 1.0)\n (a = 2, b = 2.0)\n\njulia> @inferred collect(lazy)\n2-element Vector{NamedTuple{(:a, :b),Tuple{Int64,Float64}}}:\n (a = 1, b = 1.0)\n (a = 2, b = 2.0)\n\njulia> @inferred Rows(a = [1, 2])\n2-element Rows{NamedTuple{(:a,),Tuple{Int64}},1,Tuple{Vector{Int64}},Tuple{Name{:a}}}:\n (a = 1,)\n (a = 2,)\n\nAll arguments to Rows must have the same axes. Use @inbounds to override the check.\n\njulia> result = Rows(a = 1:2, b = 1:3)\nERROR: DimensionMismatch(\"All columns passed to `Rows` must have the same axes\")\n[...]\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.gather-Tuple{Tuple{Vararg{Tuple{Name,Any},N}} where N,Vararg{Any,N} where N}","page":"Interface","title":"LightQuery.gather","text":"gather(data, new_name_old_names...)\n\nFor each new_name, old_names pair in new_name_old_names, gather the old_names into a single new_name. Inverse of spread.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> data = (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0);\n\n\njulia> @inferred gather(data, g = (name\"b\", name\"e\"), h = (name\"c\", name\"f\"))\n(a = 1, d = 1.0, g = (b = 1.0, e = 1), h = (c = 1, f = 1.0))\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.index-Tuple{Any,Any}","page":"Interface","title":"LightQuery.index","text":"index(unindexed, key_function)\n\nIndex unindexed by the results of key_function. Results of key_function must be unique.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> result = @inferred index([-2, 1], abs)\nLightQuery.Indexed{Int64,Int64,Vector{Int64},Dict{Int64,Int64}} with 2 entries:\n  2 => -2\n  1 => 1\n\njulia> @inferred result[2]\n-2\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.key-Tuple{Any}","page":"Interface","title":"LightQuery.key","text":"key(pair)\n\nThe key in a key => value pair.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred key(:a => 1)\n:a\n\njulia> @inferred key((:a, 1))\n:a\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.make_columns-Tuple{Any}","page":"Interface","title":"LightQuery.make_columns","text":"make_columns(rows)\n\nCollect into columns.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> stable(x) = (a = x, b = x + 0.0, c = x, d = x + 0.0, e = x, f = x + 0.0);\n\n\njulia> @inferred make_columns(Iterators.map(stable, 1:4))\n(a = [1, 2, 3, 4], b = [1.0, 2.0, 3.0, 4.0], c = [1, 2, 3, 4], d = [1.0, 2.0, 3.0, 4.0], e = [1, 2, 3, 4], f = [1.0, 2.0, 3.0, 4.0])\n\njulia> unstable(x) =\n           if x <= 2\n               (a = missing, b = string(x), d = string(x))\n           else\n               (a = x, b = missing, c = x)\n           end;\n\n\njulia> make_columns(Iterators.map(unstable, 1:4))\n(d = Union{Missing, String}[\"1\", \"2\", missing, missing], a = Union{Missing, Int64}[missing, missing, 3, 4], b = Union{Missing, String}[\"1\", \"2\", missing, missing], c = Union{Missing, Int64}[missing, missing, 3, 4])\n\njulia> make_columns(Iterators.filter(row -> true, Iterators.map(unstable, 1:4)))\n(d = Union{Missing, String}[\"1\", \"2\", missing, missing], a = Union{Missing, Int64}[missing, missing, 3, 4], b = Union{Missing, String}[\"1\", \"2\", missing, missing], c = Union{Missing, Int64}[missing, missing, 3, 4])\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.order-Tuple{Any,Any}","page":"Interface","title":"LightQuery.order","text":"order(unordered, key_function; keywords...)\n\nGeneralized sort. keywords will be passed to sort!; see the documentation there for options. Use By to mark that an object has been sorted. If the results of key_function are type unstable, consider using hash ∘ key_function instead.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> collect(@inferred order([-2, 1], abs))\n2-element Vector{Int64}:\n  1\n -2\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.reduce_rows-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Interface","title":"LightQuery.reduce_rows","text":"function reduce_rows(rows, a_function, columns...)\n\nReduce a function over each of columns in rows.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred reduce_rows(Rows(a = [1, 1], b = [1.0, 1.0]), +, name\"a\", name\"b\")\n(a = 2, b = 2.0)\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.remove-Tuple{Tuple{Vararg{Tuple{Name,Any},N}} where N,Vararg{Any,N} where N}","page":"Interface","title":"LightQuery.remove","text":"remove(data, old_names...)\n\nRemove old_names from data.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> data = (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0);\n\n\njulia> @inferred remove(data, name\"c\", name\"f\")\n(a = 1, b = 1.0, d = 1.0, e = 1)\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.rename-Tuple{Tuple{Vararg{Tuple{Name,Any},N}} where N,Vararg{Any,N} where N}","page":"Interface","title":"LightQuery.rename","text":"rename(data, new_name_old_names...)\n\nRename data.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> data = (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0);\n\n\njulia> @inferred rename(data, c2 = name\"c\", f2 = name\"f\")\n(a = 1, b = 1.0, d = 1.0, e = 1, c2 = 1, f2 = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.spread-Tuple{Tuple{Vararg{Tuple{Name,Any},N}} where N,Vararg{Any,N} where N}","page":"Interface","title":"LightQuery.spread","text":"spread(data, some_names...)\n\nUnnest nested named tuples. Inverse of gather.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> gathered = (a = 1, d = 1.0, g = (b = 1.0, e = 1), h = (c = 1, f = 1.0));\n\n\njulia> @inferred spread(gathered, name\"g\", name\"h\")\n(a = 1, d = 1.0, b = 1.0, e = 1, c = 1, f = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.transform-Tuple{Tuple{Vararg{Tuple{Name,Any},N}} where N,Vararg{Any,N} where N}","page":"Interface","title":"LightQuery.transform","text":"transform(data, assignments...)\n\nMerge assignments into data, overwriting old values.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> data = (a = 1, b = 1.0, c = 1, d = 1.0, e = 1, f = 1.0);\n\n\njulia> @inferred transform(data, c = 2.0, f = 2, g = 1, h = 1.0)\n(a = 1, b = 1.0, d = 1.0, e = 1, c = 2.0, f = 2, g = 1, h = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.unname-Union{Tuple{Name{name}}, Tuple{name}} where name","page":"Interface","title":"LightQuery.unname","text":"unname(::Name{name}) where name\n\nInverse of Name.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred unname(Name(:a))\n:a\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.value-Tuple{Any}","page":"Interface","title":"LightQuery.value","text":"value(pair)\n\nThe value in a key => value pair.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred value(:a => 1)\n1\n\njulia> @inferred value((:a, 1))\n1\n\n\n\n\n\n","category":"method"},{"location":"interface/#LightQuery.@>-Tuple{Any}","page":"Interface","title":"LightQuery.@>","text":"macro >(body)\n\nIf body is in the form object_ |> call_, call @_ on call, and recur on object.\n\njulia> using LightQuery\n\n\njulia> @> 0 |> _ - 1 |> abs\n1\n\nYou can nest chains:\n\njulia> @> 1 |> (@> _ + 1 |> _ + 1)\n3\n\nHandles interpolations seamlessly:\n\njulia> @> 1 |> :(_ + $_)\n:(_ + 1)\n\n\n\n\n\n","category":"macro"},{"location":"interface/#LightQuery.@_-Tuple{Any}","page":"Interface","title":"LightQuery.@_","text":"macro _(body)\n\nTerser function syntax. The arguments are inside the body; the first argument is _, the second argument is __, etc. Will @inline.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> @inferred (@_ _ + 1)(1)\n2\n\njulia> @inferred map((@_ __ - _), (1, 2), (2, 1))\n(1, -1)\n\nIf there are no _ arguments, read as is.\n\njulia> (@_ x -> x + 1)(1)\n2\n\n\n\n\n\n","category":"macro"},{"location":"interface/#LightQuery.@if_known-Tuple{Any}","page":"Interface","title":"LightQuery.@if_known","text":"@if_known(something)\n\nIf something is missing, return missing, otherwise, something.\n\njulia> using LightQuery\n\n\njulia> using Test: @inferred\n\n\njulia> function test(x)\n           first(@if_known(x))\n       end;\n\n\njulia> @inferred test((1, 2))\n1\n\njulia> @inferred test(missing)\nmissing\n\n\n\n\n\n","category":"macro"},{"location":"interface/#LightQuery.@name_str-Tuple{Any}","page":"Interface","title":"LightQuery.@name_str","text":"name_str(name)\n\nCreate a typed Name.\n\njulia> using LightQuery\n\n\njulia> name\"a\"\nname\"a\"\n\n\n\n\n\n","category":"macro"},{"location":"beginner_tutorial/#Beginner-tutorial","page":"Beginner tutorial","title":"Beginner tutorial","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"I'm using the data from the dplyr tutorial. The data is in the test folder of this package.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"I created it with the following R code:","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"library(nycflights13)\nsetwd(\"C:/Users/hp/.julia/dev/LightQuery/test\")\nwrite.csv(airports, \"airports.csv\", na = \"\", row.names = FALSE)\nwrite.csv(flights, \"flights.csv\", na = \"\", row.names = FALSE)\nwrite.csv(weathers, \"weather.csv\", na = \"\", row.names = FALSE)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"First, import some tools we will need and change the working directory.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> using LightQuery\n\njulia> using Dates: Date, DateTime, Hour\n\njulia> using Base.Iterators: flatten\n\njulia> using Tables: columntable\n\njulia> using TimeZones: Class, Local, TimeZone, VariableTimeZone, ZonedDateTime\n\njulia> using Unitful: °, °F, ft, hr, inch, mbar, mi, minute\n\njulia> cd(joinpath(pkgdir(LightQuery), \"test\"));\n","category":"page"},{"location":"beginner_tutorial/#Airports-cleaning","page":"Beginner tutorial","title":"Airports cleaning","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"The first step in cleaning up this data is to create a dataset about airports. The airports data crucially contains timezone information which we will need to adjust flight times.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Use CSV.File to import the airports data.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> using CSV: File\n\njulia> airports_file = File(\"airports.csv\", missingstrings = [\"\", \"\\\\N\"]);","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"You can use Tables.columntable to get the columns of the file. Then, immediately use Rows to iterate over the rows of the file. columntable is a key entry-point to LightQuery, because so many packages implement the Tables interace.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airports_file = Rows(; columntable(airports_file)...);","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's read in the first row and try to process it.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airport = first(airports_file)\n(faa = \"04G\", name = \"Lansdowne Airport\", lat = 41.1304722, lon = -80.6195833, alt = 1044, tz = -5, dst = \"A\", tzone = \"America/New_York\")","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Next, rename the variables to be human readable.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airport = rename(airport,\n            airport_code = name\"faa\",\n            altitude = name\"alt\",\n            daylight_savings = name\"dst\",\n            latitude = name\"lat\",\n            longitude = name\"lon\",\n            time_zone = name\"tzone\",\n            time_zone_offset = name\"tz\"\n        )\n(name = \"Lansdowne Airport\", airport_code = \"04G\", altitude = 1044, daylight_savings = \"A\", latitude = 41.1304722, longitude = -80.6195833, time_zone = \"America/New_York\", time_zone_offset = -5)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Next, remove redundant data. This data is associated with timezones, not flights.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airport = remove(airport,\n            name\"daylight_savings\",\n            name\"time_zone_offset\"\n        )\n(name = \"Lansdowne Airport\", airport_code = \"04G\", altitude = 1044, latitude = 41.1304722, longitude = -80.6195833, time_zone = \"America/New_York\")","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Next, add units to some of our variables using transform.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airport = transform(airport,\n            altitude = airport.altitude * ft,\n            latitude = airport.latitude * °,\n            longitude = airport.longitude * °\n        )\n(name = \"Lansdowne Airport\", airport_code = \"04G\", time_zone = \"America/New_York\", altitude = 1044 ft, latitude = 41.1304722°, longitude = -80.6195833°)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Next, we will write a function for getting a true timezone. This will be useful because the departure and arrival times are in various timezones. Use @if_known to handle missing data. Note the data contains some LEGACY timezones. Note that the type annotation is optional: TimeZone is unstable without it.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> get_time_zone(time_zone) = TimeZone(\n            (@if_known time_zone),\n            Class(:STANDARD) | Class(:LEGACY)\n        )::VariableTimeZone;\n\njulia> get_time_zone(airport.time_zone)\nAmerica/New_York (UTC-5/UTC-4)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Next, put all of our row processing steps together into one function. You can use the all-purpose chaining macro @> provided in this package to chain all of these steps together.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> function get_airport(row)\n            @> row |>\n            rename(_,\n                airport_code = name\"faa\",\n                altitude = name\"alt\",\n                daylight_savings = name\"dst\",\n                latitude = name\"lat\",\n                longitude = name\"lon\",\n                time_zone = name\"tzone\",\n                time_zone_offset = name\"tz\"\n            ) |>\n            remove(_,\n                name\"daylight_savings\",\n                name\"time_zone_offset\",\n            ) |>\n            transform(_,\n                altitude = _.altitude * ft,\n                latitude = _.latitude * °,\n                longitude = _.longitude * °,\n                time_zone = get_time_zone(_.time_zone)\n            )\n        end;\n\njulia> get_airport(first(airports_file))\n(name = \"Lansdowne Airport\", airport_code = \"04G\", altitude = 1044 ft, latitude = 41.1304722°, longitude = -80.6195833°, time_zone = tz\"America/New_York\")","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Use Iterators.map to lazily map this function over each row of the airports file.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airports = Iterators.map(get_airport, airports_file);","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"I will repeat the following sequence of operations many times in this tutorial. Call make_columns to store the data as columns. Then, because it is useful to view the data as rows, use Rows to lazily view the data row-wise. You can use Peek to look at the first few rows of data.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airports = Rows(; make_columns(airports)...);","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"You can use index to be able to quickly retrieve airports by code. This will be helpful later. This is very similar to making a Dict.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> const indexed_airports = index(airports, name\"airport_code\");","category":"page"},{"location":"beginner_tutorial/#Flights-cleaning","page":"Beginner tutorial","title":"Flights cleaning","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Now that we have built our airports dataset, we can start working on the flights data. We're following basically the same steps as we did above.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> flights_file =\n        @> File(\"flights.csv\") |>\n        columntable |>\n        Rows(; _...);","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Again, we will build a function to clean up a row of data. We will again use the first row to build and test our function. I will skip over several steps that we already used in the airports data: get the first flight, rename, remove, and transform to add units.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> flight =\n        @> flights_file |>\n        first |>\n        rename(_,\n            arrival_delay = name\"arr_delay\",\n            arrival_time = name\"arr_time\",\n            departure_delay = name\"dep_delay\",\n            departure_time = name\"dep_time\",\n            destination = name\"dest\",\n            scheduled_arrival_time = name\"sched_arr_time\",\n            scheduled_departure_time = name\"sched_dep_time\",\n            tail_number = name\"tailnum\"\n        ) |>\n        remove(_,\n            name\"arrival_time\",\n            name\"departure_time\",\n            name\"hour\",\n            name\"minute\",\n            name\"time_hour\"\n        ) |>\n        transform(_,\n            air_time = _.air_time * minute,\n            arrival_delay = _.arrival_delay * minute,\n            departure_delay = _.departure_delay * minute,\n            distance = _.distance * mi\n        )\n(year = 2013, month = 1, day = 1, carrier = \"UA\", flight = 1545, origin = \"EWR\", destination = \"IAH\", scheduled_arrival_time = 819, scheduled_departure_time = 515, tail_number = \"N14228\", air_time = 227 minute, arrival_delay = 11 minute, departure_delay = 2 minute, distance = 1400 mi)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's find the time_zone of the airport the flight departed from. Use @if_known to handle missing data.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> airport = @if_known get(indexed_airports, flight.origin, missing)\n(name = \"Newark Liberty Intl\", airport_code = \"EWR\", altitude = 18 ft, latitude = 40.6925°, longitude = -74.168667°, time_zone = tz\"America/New_York\")\n\njulia> time_zone = @if_known airport.time_zone\nAmerica/New_York (UTC-5/UTC-4)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Now process the departure time. We are given times as hours and minutes concatenated together. Use divrem(_, 100) to split the scheduled_departure_time.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> divrem(flight.scheduled_departure_time, 100)\n(5, 15)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's build a ZonedDateTime for the departure time.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> ZonedDateTime(\n            flight.year,\n            flight.month,\n            flight.day,\n            divrem(flight.scheduled_departure_time, 100)...,\n            time_zone\n        )\n2013-01-01T05:15:00-05:00","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"We can combine the steps for creating a ZonedDateTime into one function. Then we can use it for both the departure and the arrival times.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> get_time(indexed_airports, flight, airport, time) =\n            ZonedDateTime(\n                flight.year,\n                flight.month,\n                flight.day,\n                divrem(time, 100)...,\n                @if_known (@if_known get(indexed_airports, airport, missing)).time_zone\n            );\n\njulia> get_time(\n            indexed_airports,\n            flight,\n            flight.origin,\n            flight.scheduled_departure_time\n        )\n2013-01-01T05:15:00-05:00","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"We also used this function to build the scheduled_arrival_time.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> arrival = get_time(\n            indexed_airports,\n            flight,\n            flight.destination,\n            flight.scheduled_arrival_time\n        )\n2013-01-01T08:19:00-06:00","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's combine all of the flights row processing steps into one function.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> function get_flight(indexed_airports, row)\n            @> row |>\n            rename(_,\n                arrival_delay = name\"arr_delay\",\n                arrival_time = name\"arr_time\",\n                departure_delay = name\"dep_delay\",\n                departure_time = name\"dep_time\",\n                destination = name\"dest\",\n                scheduled_arrival_time = name\"sched_arr_time\",\n                scheduled_departure_time = name\"sched_dep_time\",\n                tail_number = name\"tailnum\"\n            ) |>\n            remove(_,\n                name\"arrival_time\",\n                name\"departure_time\",\n                name\"hour\",\n                name\"minute\",\n                name\"time_hour\"\n            ) |>\n            transform(_,\n                air_time = _.air_time * minute,\n                distance = _.distance * mi,\n                departure_delay = _.departure_delay * minute,\n                arrival_delay = _.arrival_delay * minute,\n                scheduled_departure_time =\n                    get_time(indexed_airports, _, _.origin, _.scheduled_departure_time),\n                scheduled_arrival_time =\n                    get_time(indexed_airports, _, _.destination, _.scheduled_arrival_time)\n            ) |>\n            remove(_,\n                name\"year\",\n                name\"month\",\n                name\"day\"\n            )\n        end;\n\njulia> get_flight(indexed_airports, first(flights_file))\n(carrier = \"UA\", flight = 1545, origin = \"EWR\", destination = \"IAH\", tail_number = \"N14228\", air_time = 227 minute, distance = 1400 mi, departure_delay = 2 minute, arrival_delay = 11 minute, scheduled_departure_time = ZonedDateTime(2013, 1, 1, 5, 15, tz\"America/New_York\"), scheduled_arrival_time = ZonedDateTime(2013, 1, 1, 8, 19, tz\"America/Chicago\"))","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Again, use Iterators.map to lazily map this function over each row. Here we are using the @_ macro to create an anonymous function as tersely as possible. Finally, we will again use make_columns and Rows to store the data column-wise and view it row-wise. Again use Peek to view the first few rows.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> flights =\n        @> flights_file |>\n        Iterators.map((@_ get_flight(indexed_airports, _)), _);","category":"page"},{"location":"beginner_tutorial/#Grouping-and-validating-flights","page":"Beginner tutorial","title":"Grouping and validating flights","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Now that we have cleaned the data, what should we do with? One simple question we might want to answer is whether the distances between two airports is always the same. If this is not the case, there is an inconsistency in the data. Answering this question will also allow me to show off the grouping features of the package. For both joining and grouping, LightQuery requires your data to be pre-sorted. This is greatly improves performance. Consider keeping your data pre-sorted to begin with!","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Thus, first, we will need to order flights by origin, destination, and distance. Note that we are using a tuple of Names as a selector function to pass to order. Once the data is in order, we can  Group By the same variables. By is necessary before grouping and joining to tell LightQuery how your data is ordered. All flights with the same origin, destination, and distance will be put into one group.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> paths_grouped =\n        @> flights |>\n        order(_, (name\"origin\", name\"destination\", name\"distance\")) |>\n        Group(By(_, (name\"origin\", name\"destination\", name\"distance\")));\n","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Each Group contains a key and value. The key is what we use to group the rows, and the value is a group of rows which all have the same key. We can look at the first few rows in a group using Peek.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> path = first(paths_grouped);\n\njulia> key(path)\n(origin = \"EWR\", destination = \"ALB\", distance = 143 mi)\n\njulia> value(path) |> Peek\nShowing 4 of 439 rows\n| carrier | flight | origin | destination | tail_number |  air_time | distance | departure_delay | arrival_delay |  scheduled_departure_time |    scheduled_arrival_time |\n| -------:| ------:| ------:| -----------:| -----------:| ---------:| --------:| ---------------:| -------------:| -------------------------:| -------------------------:|\n|      EV |   4112 |    EWR |         ALB |      N13538 | 33 minute |   143 mi |       -2 minute |    -10 minute | 2013-01-01T13:17:00-05:00 | 2013-01-01T14:23:00-05:00 |\n|      EV |   3260 |    EWR |         ALB |      N19554 | 36 minute |   143 mi |       34 minute |     40 minute | 2013-01-01T16:21:00-05:00 | 2013-01-01T17:24:00-05:00 |\n|      EV |   4170 |    EWR |         ALB |      N12540 | 31 minute |   143 mi |       52 minute |     44 minute | 2013-01-01T20:04:00-05:00 | 2013-01-01T21:12:00-05:00 |\n|      EV |   4316 |    EWR |         ALB |      N14153 | 33 minute |   143 mi |        5 minute |    -14 minute | 2013-01-02T13:27:00-05:00 | 2013-01-02T14:33:00-05:00 |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"For the purposes of our analysis, all we need is the key. As always, store the data as columns using make_columns, lazily view it as rows using Rows, and use Peek to view the first few rows.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> paths =\n        @> paths_grouped |>\n        Iterators.map(key, _) |>\n        make_columns |>\n        Rows(; _ ...);\n\njulia> Peek(paths)\nShowing 4 of 226 rows\n| origin | destination | distance |\n| ------:| -----------:| --------:|\n|    EWR |         ALB |   143 mi |\n|    EWR |         ANC |  3370 mi |\n|    EWR |         ATL |   746 mi |\n|    EWR |         AUS |  1504 mi |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's run our data through a second round of grouping. This time, we will group data only by origin and destination. Theoretically, each group should only be one row long, because the distance between an origin and destination airport should always be the same. Our data is already sorted, so we do not need to sort it again before grouping. Again, use Group and By to group the rows. Again, we can pass a tuple of Names as a selector function. Then, for each group, we can find the number of rows it contains.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> path_groups =\n        @> paths |>\n        Group(By(_, (name\"origin\", name\"destination\")));","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's create a function to add the number of distinct distances to the key.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> first_path_group = first(path_groups);\n\njulia> key(first_path_group)\n(origin = \"EWR\", destination = \"ALB\")\n\njulia> Peek(value(first_path_group))\n| origin | destination | distance |\n| ------:| -----------:| --------:|\n|    EWR |         ALB |   143 mi |\n\njulia> function with_number((key, value))\n            transform(key, number = length(value))\n        end;\n\njulia> with_number(first_path_group)\n(origin = \"EWR\", destination = \"ALB\", number = 1)","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"We can take a Peek at the first few results.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> distinct_distances =\n        @> path_groups |>\n        Iterators.map(with_number, _);\n\njulia> Peek(distinct_distances)\nShowing at most 4 rows\n| origin | destination | number |\n| ------:| -----------:| ------:|\n|    EWR |         ALB |      1 |\n|    EWR |         ANC |      1 |\n|    EWR |         ATL |      1 |\n|    EWR |         AUS |      1 |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's see when there are multiple distances for the same path using Iterators.filter. Again, use @_ to create an anonymous function to pass to Iterators.filter.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> @> distinct_distances |>\n        Iterators.filter((@_ _.number != 1), _) |>\n        Peek\nShowing at most 4 rows\n| origin | destination | number |\n| ------:| -----------:| ------:|\n|    EWR |         EGE |      2 |\n|    JFK |         EGE |      2 |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"It looks like there is a consistency with flights which arrive at at the EGE airport. Let's take a Peek at flights going to \"EGE\" using Iterators.filter. Again, use @_ to create an anonymous function to pass to Iterators.filter.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> @> flights |>\n        Iterators.filter((@_ _.destination == \"EGE\"), _) |>\n        Peek\nShowing at most 4 rows\n| carrier | flight | origin | destination | tail_number |   air_time | distance | departure_delay | arrival_delay |  scheduled_departure_time |    scheduled_arrival_time |\n| -------:| ------:| ------:| -----------:| -----------:| ----------:| --------:| ---------------:| -------------:| -------------------------:| -------------------------:|\n|      UA |   1597 |    EWR |         EGE |      N27733 | 287 minute |  1726 mi |       -2 minute |     13 minute | 2013-01-01T09:28:00-05:00 | 2013-01-01T12:20:00-07:00 |\n|      AA |    575 |    JFK |         EGE |      N5DRAA | 280 minute |  1747 mi |       -5 minute |      3 minute | 2013-01-01T17:00:00-05:00 | 2013-01-01T19:50:00-07:00 |\n|      UA |   1597 |    EWR |         EGE |      N24702 | 261 minute |  1726 mi |        1 minute |      3 minute | 2013-01-02T09:28:00-05:00 | 2013-01-02T12:20:00-07:00 |\n|      AA |    575 |    JFK |         EGE |      N631AA | 260 minute |  1747 mi |        5 minute |     16 minute | 2013-01-02T17:00:00-05:00 | 2013-01-02T19:50:00-07:00 |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"You can see just in these rows that there is an inconsistency in the data. The distance for the first two rows should be the same as the distance for the second two rows.","category":"page"},{"location":"beginner_tutorial/#Weather-cleaning","page":"Beginner tutorial","title":"Weather cleaning","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Perhaps I want to know weather influences the departure delay. To do this, I will need to join weather data into the flights data. Start by cleaning the weather data using basically the same steps as above. Get the first row, rename, remove, and transform to add units.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> weathers_file =\n        @> File(\"weather.csv\") |>\n        columntable |>\n        Rows(; _...);\n\njulia> function get_weather(indexed_airports, row)\n            @> row |>\n            rename(_,\n                airport_code = name\"origin\",\n                dew_point = name\"dewp\",\n                humidity = name\"humid\",\n                precipitation = name\"precip\",\n                temperature = name\"temp\",\n                visibility = name\"visib\",\n                wind_direction = name\"wind_dir\"\n            ) |>\n            transform(_,\n                dew_point = _.dew_point * °F,\n                humidity = _.humidity / 100,\n                precipitation = _.precipitation * inch,\n                pressure = _.pressure * mbar,\n                temperature = _.temperature * °F,\n                visibility = _.visibility * mi,\n                wind_direction = _.wind_direction * °,\n                wind_gust = _.wind_gust * mi / hr,\n                wind_speed = _.wind_speed * mi / hr,\n                date_time = ZonedDateTime(\n                    _.year,\n                    _.month,\n                    _.day,\n                    _.hour,\n                    indexed_airports[_.airport_code].time_zone,\n                    1\n                )\n            ) |>\n            remove(_,\n                name\"year\",\n                name\"month\",\n                name\"day\",\n                name\"hour\"\n            )\n        end;\n\njulia> weathers =\n        @> weathers_file |>\n        Iterators.map((@_ get_weather(indexed_airports, _)), _);\n\njulia> Peek(weathers)\nShowing 4 of 26115 rows\n|           time_hour | airport_code | dew_point |           humidity | precipitation |    pressure | temperature | visibility | wind_direction | wind_gust |        wind_speed |                 date_time |\n| -------------------:| ------------:| ---------:| ------------------:| -------------:| -----------:| -----------:| ----------:| --------------:| ---------:| -----------------:| -------------------------:|\n| 2013-01-01 01:00:00 |          EWR |  26.06 °F |             0.5937 |      0.0 inch | 1012.0 mbar |    39.02 °F |    10.0 mi |           270° |   missing | 10.35702 mi hr^-1 | 2013-01-01T01:00:00-05:00 |\n| 2013-01-01 02:00:00 |          EWR |  26.96 °F | 0.6163000000000001 |      0.0 inch | 1012.3 mbar |    39.02 °F |    10.0 mi |           250° |   missing |  8.05546 mi hr^-1 | 2013-01-01T02:00:00-05:00 |\n| 2013-01-01 03:00:00 |          EWR |  28.04 °F | 0.6443000000000001 |      0.0 inch | 1012.5 mbar |    39.02 °F |    10.0 mi |           240° |   missing |  11.5078 mi hr^-1 | 2013-01-01T03:00:00-05:00 |\n| 2013-01-01 04:00:00 |          EWR |  28.04 °F |             0.6221 |      0.0 inch | 1012.2 mbar |    39.92 °F |    10.0 mi |           250° |   missing | 12.65858 mi hr^-1 | 2013-01-01T04:00:00-05:00 |","category":"page"},{"location":"beginner_tutorial/#Joining-flights-and-weather","page":"Beginner tutorial","title":"Joining flights and weather","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"I happen to know that the weather data is already sorted by airport_code and hour. However, we will need to presort and group the flights before we can join in the weather file. Joining in LightQuery is never many-to-one; you always need to explicitly group first. This is slightly less convenient but allows some extra flexibility.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"order and Group flights By matching variables. We will join the flights to the weather data by rounding down the scheduled departure time of the flight to the nearest hour. Only use data when the departure_delay is present.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> grouped_flights =\n        @> flights |>\n        Iterators.filter((@_ _.departure_delay !== missing), _) |>\n        order(_, (name\"origin\", name\"scheduled_departure_time\")) |>\n        Group(By(_, @_ (_.origin, floor(_.scheduled_departure_time, Hour))));\n\njulia> key(first(grouped_flights))\n(\"EWR\", ZonedDateTime(2013, 1, 1, 5, tz\"America/New_York\"))","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"An inner join will find pairs rows with matching keys. Groups of flights are already sorted by key.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> weathers_to_flights = @> InnerJoin(\n            By(weathers, @_ (_.airport_code, _.date_time)),\n            By(grouped_flights, key)\n        );\n","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Let's look at the first match. This will contain weather data, and a group of flights.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> a_match = first(weathers_to_flights);\n\njulia> weather, (flights_key, flights_value) = a_match;\n\njulia> weather\n(time_hour = \"2013-01-01 05:00:00\", airport_code = \"EWR\", dew_point = 28.04 °F, humidity = 0.6443000000000001, precipitation = 0.0 inch, pressure = 1011.9 mbar, temperature = 39.02 °F, visibility = 10.0 mi, wind_direction = 260°, wind_gust = missing, wind_speed = 12.65858 mi hr^-1, date_time = ZonedDateTime(2013, 1, 1, 5, tz\"America/New_York\"))\n\njulia> flights_key\n(\"EWR\", ZonedDateTime(2013, 1, 1, 5, tz\"America/New_York\"))\n\njulia> Peek(flights_value)\n| carrier | flight | origin | destination | tail_number |   air_time | distance | departure_delay | arrival_delay |  scheduled_departure_time |    scheduled_arrival_time |\n| -------:| ------:| ------:| -----------:| -----------:| ----------:| --------:| ---------------:| -------------:| -------------------------:| -------------------------:|\n|      UA |   1545 |    EWR |         IAH |      N14228 | 227 minute |  1400 mi |        2 minute |     11 minute | 2013-01-01T05:15:00-05:00 | 2013-01-01T08:19:00-06:00 |\n|      UA |   1696 |    EWR |         ORD |      N39463 | 150 minute |   719 mi |       -4 minute |     12 minute | 2013-01-01T05:58:00-05:00 | 2013-01-01T07:28:00-06:00 |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"We're interested in visibility and departure_delay. We have one row of weather data on the left but multiple flights on the right. Thus, for each flight, we will need to add in the weather data we are interested in.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> visibility = weather.visibility;\n\njulia> Iterators.map((@_ (\n            visibility = visibility,\n            departure_delay = _.departure_delay\n        )), flights_value) |>\n        Peek\n| visibility | departure_delay |\n| ----------:| ---------------:|\n|    10.0 mi |        2 minute |\n|    10.0 mi |       -4 minute |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"We will need to conduct these steps for each match. So put them together into a function.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> function interested_in(a_match)\n            weather, (flights_key, flights_value) = a_match\n            visibility = weather.visibility\n            Iterators.map((@_ (\n                visibility = visibility,\n                departure_delay = _.departure_delay\n            )), flights_value)\n        end;\n\njulia> Peek(interested_in(a_match))\n| visibility | departure_delay |\n| ----------:| ---------------:|\n|    10.0 mi |        2 minute |\n|    10.0 mi |       -4 minute |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"For each match, we are returning several rows. Use Base.Iterators.flatten to unnest data and get a single iterator of rows. Collect the result.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> data =\n        @> weathers_to_flights |>\n        Iterators.map(interested_in, _) |>\n        flatten |>\n        make_columns |>\n        Rows(; _...);\n\njulia> Peek(data)\nShowing 4 of 326993 rows\n| visibility | departure_delay |\n| ----------:| ---------------:|\n|    10.0 mi |        2 minute |\n|    10.0 mi |       -4 minute |\n|    10.0 mi |       -5 minute |\n|    10.0 mi |       -2 minute |","category":"page"},{"location":"beginner_tutorial/#Visibility-vs.-departure-delay","page":"Beginner tutorial","title":"Visibility vs. departure delay","text":"","category":"section"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Now we can finally answer the question we are interested in. How does visibility affect departure_delay? First, let's group by visibility.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> by_visibility =\n        @> data |>\n        order(_, name\"visibility\") |>\n        Group(By(_, name\"visibility\"));\n\njulia> visibility_group = first(by_visibility);\n\njulia> key(visibility_group)\n0.0 mi\n\njulia> value(visibility_group) |> Peek\nShowing 4 of 87 rows\n| visibility | departure_delay |\n| ----------:| ---------------:|\n|     0.0 mi |       -5 minute |\n|     0.0 mi |       -1 minute |\n|     0.0 mi |       -8 minute |\n|     0.0 mi |       -7 minute |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"For each group, we can calculate the mean departure_delay.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> using Statistics: mean\n\njulia> @> visibility_group |>\n        value |>\n        Iterators.map(name\"departure_delay\", _) |>\n        mean\n32.252873563218394 minute","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"Now run it for all the groups.","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"julia> get_mean_departure_delay(visibility_group) = (\n            visibility = key(visibility_group),\n            mean_departure_delay =\n                (@> visibility_group |>\n                    value |>\n                    Iterators.map(name\"departure_delay\", _) |>\n                    mean),\n            count = length(value(visibility_group))\n        );\n\njulia> @> by_visibility |>\n            Iterators.map(get_mean_departure_delay, _) |>\n            Peek(_, 20)\nShowing at most 20 rows\n| visibility |      mean_departure_delay |  count |\n| ----------:| -------------------------:| ------:|\n|     0.0 mi | 32.252873563218394 minute |     87 |\n|    0.06 mi |               22.2 minute |     85 |\n|    0.12 mi |  50.69975186104218 minute |    403 |\n|    0.25 mi | 20.481110254433307 minute |   1297 |\n|     0.5 mi |   32.5890826383624 minute |   1319 |\n|    0.75 mi |  30.06759906759907 minute |    429 |\n|     1.0 mi |  32.24348473566642 minute |   1343 |\n|    1.25 mi | 53.187845303867405 minute |    181 |\n|     1.5 mi |  25.90661478599222 minute |   1542 |\n|    1.75 mi | 43.333333333333336 minute |    132 |\n|     2.0 mi | 22.701923076923077 minute |   2912 |\n|     2.5 mi |  21.18074398249453 minute |   2285 |\n|     3.0 mi |   21.2113218731476 minute |   3374 |\n|     4.0 mi |  19.48311444652908 minute |   2132 |\n|     5.0 mi |  21.10387902695595 minute |   4563 |\n|     6.0 mi | 19.807032301480483 minute |   5944 |\n|     7.0 mi | 19.208963745361118 minute |   7006 |\n|     8.0 mi |  19.98660103910309 minute |   7314 |\n|     9.0 mi | 18.762949476558944 minute |  10985 |\n|    10.0 mi | 10.951549367828692 minute | 273660 |","category":"page"},{"location":"beginner_tutorial/","page":"Beginner tutorial","title":"Beginner tutorial","text":"This data suggests that low visibility levels lead to larger departure delays, on average.","category":"page"},{"location":"reshaping_tutorial/#Reshaping-tutorial","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"","category":"section"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"For this section, I will use data from the Global Historical Climatology Network. I got this idea from the tidyr tutorial. This example assumes you have already worked through the Beginner tutorial. Let's take a quick peek at the data.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> using LightQuery\n\njulia> using Base.Iterators: flatten\n\njulia> using Dates: Date\n\njulia> cd(joinpath(pathof(LightQuery) |> dirname |> dirname, \"test\"));","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> file = open(\"climate.txt\");\n\njulia> line = readline(file)\n\"ACW00011604194901TMAX  289  X  289  X  283  X  283  X  289  X  289  X  278  X  267  X  272  X  278  X  267  X  278  X  267  X  267  X  278  X  267  X  267  X  272  X  272  X  272  X  278  X  272  X  267  X  267  X  267  X  278  X  272  X  272  X  272  X  272  X  272  X\"\n\njulia> close(file)","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Oh boy this is some messy data. Let's start by parsing the first chunk, which contains within it the year and the month.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> month_variable = (\n            year = parse(Int, SubString(line, 12, 15)),\n            month = parse(Int, SubString(line, 16, 17)),\n            variable = Symbol(SubString(line, 18, 21))\n        )\n(year = 1949, month = 1, variable = :TMAX)","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"The next chucks each represent a day. Let's parse a day. missing is represented by -9999.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> function get_day(line, day)\n            start = 14 + 8 * day\n            value = parse(Int, line[start:start + 4])\n            (day = day, value =\n                if value == -9999\n                    missing\n                else\n                    value\n                end\n            )\n        end;\n\n\njulia> get_day(line, 1)\n(day = 1, value = 289)","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Now, we can get data for every day of the month.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> days = Iterators.map((@_ merge(month_variable, get_day(line, _))), 1:31);\n\njulia> first(days)\n(year = 1949, month = 1, variable = :TMAX, day = 1, value = 289)","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Use Iterators.filter to remove missing data;","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> days = Iterators.filter((@_ _.value !== missing), days);\n\n\njulia> first(days)\n(year = 1949, month = 1, variable = :TMAX, day = 1, value = 289)","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Use transform a true data and remove the old fields.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> get_date(day) =\n        @> day |>\n        transform(_, date = Date(_.year, _.month, _.day)) |>\n        remove(_, name\"year\", name\"month\", name\"day\");\n\n\njulia> get_date(first(days)) == (\n            variable = :TMAX,\n            value = 289,\n            date = Date(\"1949-01-01\")\n        )\ntrue","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"We can combine these steps to process a whole month.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> function get_month_variable(line)\n            month_variable = (\n                year = parse(Int, SubString(line, 12, 15)),\n                month = parse(Int, SubString(line, 16, 17)),\n                variable = Symbol(SubString(line, 18, 21))\n            )\n            @> Iterators.map((@_ merge(month_variable, get_day(line, _))), 1:31) |>\n            Iterators.filter((@_ _.value !== missing), _) |>\n            Iterators.map(get_date, _)\n        end;\n\n\njulia> first(get_month_variable(line)) == (\n            variable = :TMAX,\n            value = 289,\n            date = Date(\"1949-01-01\")\n        )\ntrue","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Each line will return several days. Use flatten to unnest the data.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> climate_data =\n        @> eachline(\"climate.txt\") |>\n        Iterators.map(get_month_variable, _) |>\n        flatten |>\n        make_columns |>\n        Rows(; _...);\n\njulia> Peek(climate_data)\nShowing 4 of 1231 rows\n| variable | value |       date |\n| --------:| -----:| ----------:|\n|    :TMAX |   289 | 1949-01-01 |\n|    :TMAX |   289 | 1949-01-02 |\n|    :TMAX |   283 | 1949-01-03 |\n|    :TMAX |   283 | 1949-01-04 |","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Let's sort and group the data by date. This will allow us to combine various measures into one row for each date.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> by_date =\n        @> climate_data |>\n        order(_, name\"date\") |>\n        Group(By(_, name\"date\"));\n\njulia> day_variables = first(by_date);\n\njulia> key(day_variables)\n1949-01-01\n\njulia> value(day_variables) |> Peek\nShowing 4 of 5 rows\n| variable | value |       date |\n| --------:| -----:| ----------:|\n|    :TMAX |   289 | 1949-01-01 |\n|    :TMIN |   217 | 1949-01-01 |\n|    :PRCP |     0 | 1949-01-01 |\n|    :SNOW |     0 | 1949-01-01 |","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Use transform to add all the new variables to the day key.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> spread_variables(day_variables) = transform((date = key(day_variables),);\n            Iterators.map(\n                (@_ _.variable => _.value),\n                value(day_variables)\n            )...\n        );\n\n\njulia> spread_variables(day_variables) == (\n            date = Date(\"1949-01-01\"),\n            TMAX = 289,\n            TMIN = 217,\n            PRCP = 0,\n            SNOW = 0,\n            SNWD = 0\n        )\ntrue","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"Finally, we can run this reshaping over each day in the data using Iterators.map.","category":"page"},{"location":"reshaping_tutorial/","page":"Reshaping tutorial","title":"Reshaping tutorial","text":"julia> @> by_date |>\n        Iterators.map(spread_variables, _) |>\n        Peek\nShowing at most 4 rows\n|    WT16 |       date | TMAX | TMIN | PRCP | SNOW | SNWD |\n| -------:| ----------:| ----:| ----:| ----:| ----:| ----:|\n| missing | 1949-01-01 |  289 |  217 |    0 |    0 |    0 |\n|       1 | 1949-01-02 |  289 |  228 |   30 |    0 |    0 |\n| missing | 1949-01-03 |  283 |  222 |    0 |    0 |    0 |\n|       1 | 1949-01-04 |  283 |  233 |    0 |    0 |    0 |","category":"page"},{"location":"#Usage-and-performance-notes","page":"Usage and performance notes","title":"Usage and performance notes","text":"","category":"section"},{"location":"","page":"Usage and performance notes","title":"Usage and performance notes","text":"LightQuery is highly optimized for long datasets with a small number of columns (< 100). The tradeoff is similar to the tradeoff between using StaticArrays and Arrays. It is strongly recommended to only select the columns you need before using LightQuery. Alternatively, you could use a package like DataFrames.","category":"page"},{"location":"","page":"Usage and performance notes","title":"Usage and performance notes","text":"You can avoid most allocations in LightQuery by keeping your data pre-sorted. If your data is not pre-sorted, then the majority of run-time will likely be spent in sorting.","category":"page"},{"location":"","page":"Usage and performance notes","title":"Usage and performance notes","text":"LightQuery requires that all of your columns have the same indices. The Rows constructor will check whether this is the case; to override these checks, use @inbounds.","category":"page"}]
}
