<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · LightQuery.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightQuery.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#Macros-1">Macros</a></li><li><a class="toctext" href="#Columns-1">Columns</a></li><li><a class="toctext" href="#Rows-1">Rows</a></li><li><a class="toctext" href="#Pivot-1">Pivot</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/bramtayl/LightQuery.jl/blob/master/test/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><p>I&#39;m going to use the flights data from the <a href="https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html">dplyr tutorial</a>. This data is in the test folder of this package; I created it with the following R code:</p><pre><code class="language-R">library(nycflights13)
setwd(&quot;C:/Users/hp/.julia/dev/LightQuery/test&quot;)
write.csv(airports, &quot;airports.csv&quot;, na = &quot;&quot;, row.names = FALSE)
write.csv(flights, &quot;flights.csv&quot;, na = &quot;&quot;, row.names = FALSE)</code></pre><p>Let&#39;s import the tools we need. I&#39;m pulling in from tools from <code>Dates</code>, <code>TimeZones</code>, and <code>Unitful</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; using Dates: DateTime, Day

julia&gt; import Dates: Minute

julia&gt; Minute(::Missing) = missing;

julia&gt; using Unitful: mi, °, ft

julia&gt; using TimeZones: ZonedDateTime, Class, VariableTimeZone

julia&gt; import TimeZones: TimeZone

julia&gt; TimeZone(::Missing, ::Class) = missing;</code></pre><p>I re-export <a href="http://juliadata.github.io/CSV.jl/stable/"><code>CSV</code></a> for input-output. See the documentation there for information about <a href="http://juliadata.github.io/CSV.jl/stable/#CSV.File"><code>CSV.File</code></a>.</p><pre><code class="language-julia-repl">julia&gt; airports_file = CSV.File(&quot;airports.csv&quot;,
            allowmissing = :auto,
            missingstrings = [&quot;&quot;, &quot;\\N&quot;]
        )
CSV.File(&quot;airports.csv&quot;, rows=1458):
Tables.Schema:
 :faa    String
 :name   String
 :lat    Float64
 :lon    Float64
 :alt    Int64
 :tz     Int64
 :dst    String
 :tzone  Union{Missing, String}</code></pre><p>We use <a href="#LightQuery.row_type"><code>row_type</code></a> to see what type rows this will return:</p><p>isconcretetype</p><pre><code class="language-julia-repl">julia&gt; const Airport = row_type(airports_file)
Tuple{Tuple{LightQuery.Name{:faa},String},Tuple{LightQuery.Name{:name},String},Tuple{LightQuery.Name{:lat},Float64},Tuple{LightQuery.Name{:lon},Float64},Tuple{LightQuery.Name{:alt},Int64},Tuple{LightQuery.Name{:tz},Int64},Tuple{LightQuery.Name{:dst},String},Tuple{LightQuery.Name{:tzone},T} where T&lt;:Union{Missing, String}}</code></pre><p>Let&#39;s take a look at the first row. Use <a href="#LightQuery.named_tuple"><code>named_tuple</code></a> to coerce a <code>CSV.Row</code> to a named tuple. I use the chaining macro <a href="#LightQuery.@&gt;"><code>@&gt;</code></a> to chain calls together.</p><pre><code class="language-julia-repl">julia&gt; airport =
        @&gt; airports_file |&gt;
        first |&gt;
        named_tuple(_)::Airport
((faa, &quot;04G&quot;), (name, &quot;Lansdowne Airport&quot;), (lat, 41.1304722), (lon, -80.6195833), (alt, 1044), (tz, -5), (dst, &quot;A&quot;), (tzone, &quot;America/New_York&quot;))</code></pre><p>You&#39;ll probably notice this doesn&#39;t look like the NamedTuples you&#39;re probably familiar with. I&#39;ve created a homemade version of NamedTuples.</p><p>As a start, I want to rename so that I understand what the columns mean. I use the [<code>@name</code>] macro to switch to my version of named tuples.</p><pre><code class="language-julia-repl">julia&gt; airport =
        @name @&gt; airport |&gt;
        rename(_,
            airport_code = :faa,
            latitude = :lat,
            longitude = :lon,
            altitude = :alt,
            time_zone_offset = :tz,
            daylight_savings = :dst,
            time_zone = :tzone
        )
((name, &quot;Lansdowne Airport&quot;), (airport_code, &quot;04G&quot;), (latitude, 41.1304722), (longitude, -80.6195833), (altitude, 1044), (time_zone_offset, -5), (daylight_savings, &quot;A&quot;), (time_zone, &quot;America/New_York&quot;))</code></pre><p>Let&#39;s create a proper <code>TimeZone</code>. Note the data contains some <code>LEGACY</code> timezones. Note the type annotation: <code>TimeZone</code> is unstable without it.</p><pre><code class="language-julia-repl">julia&gt; const time_zone_classes = Class(:STANDARD) | Class(:LEGACY);

julia&gt; airport =
        @name @&gt; airport |&gt;
        transform(_,
            time_zone = TimeZone(_.time_zone, time_zone_classes)::Union{VariableTimeZone, Missing}
        )
((name, &quot;Lansdowne Airport&quot;), (airport_code, &quot;04G&quot;), (latitude, 41.1304722), (longitude, -80.6195833), (altitude, 1044), (time_zone_offset, -5), (daylight_savings, &quot;A&quot;), (time_zone, tz&quot;America/New_York&quot;))</code></pre><p>Now that we have a true timezone, we can <a href="#LightQuery.remove"><code>remove</code></a> all data that is contingent on timezone.</p><pre><code class="language-julia-repl">julia&gt; airport =
        @name @&gt; airport |&gt;
        remove(_,
            :time_zone_offset,
            :daylight_savings
        )
((name, &quot;Lansdowne Airport&quot;), (airport_code, &quot;04G&quot;), (latitude, 41.1304722), (longitude, -80.6195833), (altitude, 1044), (time_zone, tz&quot;America/New_York&quot;))</code></pre><p>Let&#39;s also add proper units to our variables.</p><pre><code class="language-julia-repl">julia&gt; airport =
        @name @&gt; airport |&gt;
        transform(_,
            latitude = _.latitude * °,
            longitude = _.longitude * °,
            altitude = _.altitude * ft
        )
((name, &quot;Lansdowne Airport&quot;), (airport_code, &quot;04G&quot;), (time_zone, tz&quot;America/New_York&quot;), (latitude, 41.1304722°), (longitude, -80.6195833°), (altitude, 1044 ft))</code></pre><p>Let&#39;s put it all together.</p><pre><code class="language-julia-repl">julia&gt; function process_airport(row)
            @name @&gt; row |&gt;
            named_tuple(_)::Airport |&gt;
            rename(_,
                airport_code = :faa,
                latitude = :lat,
                longitude = :lon,
                altitude = :alt,
                time_zone_offset = :tz,
                daylight_savings = :dst,
                time_zone = :tzone
            ) |&gt;
            transform(_,
                time_zone = TimeZone(_.time_zone, time_zone_classes)::Union{VariableTimeZone, Missing},
                latitude = _.latitude * °,
                longitude = _.longitude * °,
                altitude = _.altitude * ft
            ) |&gt;
            remove(_,
                :time_zone_offset,
                :daylight_savings
            )
        end;</code></pre><p>I use <a href="#LightQuery.over"><code>over</code></a> to lazily <code>map</code>.</p><pre><code class="language-julia-repl">julia&gt; airports =
        @&gt; airports_file |&gt;
        over(_, process_airport);</code></pre><p>When it comes time to collect, I&#39;m calling <a href="#LightQuery.make_columns"><code>make_columns</code></a> then <a href="#LightQuery.rows"><code>rows</code></a>. It makes sense to store this data column-wise. This is because there are multiple columns that might contain missing data.</p><pre><code class="language-julia-repl">julia&gt; airports =
        airports |&gt;
        make_columns |&gt;
        rows;</code></pre><p>We can use <a href="#LightQuery.Peek"><code>Peek</code></a> to get a look at the data.</p><pre><code class="language-julia-repl">julia&gt; Peek(airports)
Showing 4 of 1458 rows
|                          name | airport_code |                      time_zone |    latitude |    longitude | altitude |
| -----------------------------:| ------------:| ------------------------------:| -----------:| ------------:| --------:|
|             Lansdowne Airport |          04G | America/New_York (UTC-5/UTC-4) | 41.1304722° | -80.6195833° |  1044 ft |
| Moton Field Municipal Airport |          06A |  America/Chicago (UTC-6/UTC-5) | 32.4605722° | -85.6800278° |   264 ft |
|           Schaumburg Regional |          06C |  America/Chicago (UTC-6/UTC-5) | 41.9893408° | -88.1012428° |   801 ft |
|               Randall Airport |          06N | America/New_York (UTC-5/UTC-4) |  41.431912° | -74.3915611° |   523 ft |</code></pre><p>I&#39;ll also make sure the airports are <a href="#LightQuery.indexed"><code>indexed</code></a> by their code so we can access them quickly.</p><pre><code class="language-julia-repl">julia&gt; const indexed_airports =
        @name @&gt; airports |&gt;
        indexed(_, :airport_code);

julia&gt; indexed_airports[&quot;JFK&quot;]
((name, &quot;John F Kennedy Intl&quot;), (airport_code, &quot;JFK&quot;), (time_zone, tz&quot;America/New_York&quot;), (latitude, 40.639751°), (longitude, -73.778925°), (altitude, 13 ft))</code></pre><p>That was just the warm-up. Now let&#39;s get started working on the flights data.</p><pre><code class="language-julia-repl">julia&gt; flights_file = CSV.File(&quot;flights.csv&quot;, allowmissing = :auto)
CSV.File(&quot;flights.csv&quot;, rows=336776):
Tables.Schema:
 :year            Int64
 :month           Int64
 :day             Int64
 :dep_time        Union{Missing, Int64}
 :sched_dep_time  Int64
 :dep_delay       Union{Missing, Int64}
 :arr_time        Union{Missing, Int64}
 :sched_arr_time  Int64
 :arr_delay       Union{Missing, Int64}
 :carrier         String
 :flight          Int64
 :tailnum         Union{Missing, String}
 :origin          String
 :dest            String
 :air_time        Union{Missing, Int64}
 :distance        Int64
 :hour            Int64
 :minute          Int64
 :time_hour       String

julia&gt; const Flight = row_type(flights_file);

julia&gt; flight =
        @name @&gt; flights_file |&gt;
        first |&gt;
        named_tuple(_)::Flight |&gt;
        rename(_,
            departure_time = :dep_time,
            scheduled_departure_time = :sched_dep_time,
            departure_delay = :dep_delay,
            arrival_time = :arr_time,
            scheduled_arrival_time = :sched_arr_time,
            arrival_delay = :arr_delay,
            tail_number = :tailnum,
            destination = :dest
        )
((year, 2013), (month, 1), (day, 1), (carrier, &quot;UA&quot;), (flight, 1545), (origin, &quot;EWR&quot;), (air_time, 227), (distance, 1400), (hour, 5), (minute, 15), (time_hour, &quot;2013-01-01 05:00:00&quot;), (departure_time, 517), (scheduled_departure_time, 515), (departure_delay, 2), (arrival_time, 830), (scheduled_arrival_time, 819), (arrival_delay, 11), (tail_number, &quot;N14228&quot;), (destination, &quot;IAH&quot;))</code></pre><p>We can use our <code>airports</code> data to make datetimes with timezones.</p><pre><code class="language-julia-repl">julia&gt; scheduled_departure_time = ZonedDateTime(
            DateTime(flight.year, flight.month, flight.day, flight.hour, flight.minute),
            indexed_airports[flight.origin].time_zone
        )
2013-01-01T05:15:00-05:00</code></pre><p>Note the scheduled arrival time is <code>818</code>. This means <code>8:18</code>. We can use <code>divrem(_, 100)</code> to split it up. Not all destinations are not in the <code>flights</code> dataset. If it was an overnight flight, add a day to the arrival time.</p><pre><code class="language-julia-repl">julia&gt; if haskey(indexed_airports, flight.destination)
            maybe_arrival_time = ZonedDateTime(
                DateTime(flight.year, flight.month, flight.day, divrem(flight.scheduled_arrival_time, 100)...),
                indexed_airports[flight.destination].time_zone
            )
            scheduled_arrival_time =
                if maybe_arrival_time &lt; scheduled_departure_time
                    maybe_arrival_time + Day(1)
                else
                    maybe_arrival_time
                end
        else
            scheduled_arrival_time = missing
        end
2013-01-01T08:19:00-06:00</code></pre><p>Let&#39;s put it all together.</p><pre><code class="language-julia-repl">julia&gt; function process_flight(row)
            flight =
                @name @&gt; row |&gt;
                named_tuple(_)::Flight |&gt;
                rename(_,
                    departure_time = :dep_time,
                    scheduled_departure_time = :sched_dep_time,
                    departure_delay = :dep_delay,
                    arrival_time = :arr_time,
                    scheduled_arrival_time = :sched_arr_time,
                    arrival_delay = :arr_delay,
                    tail_number = :tailnum,
                    destination = :dest
                )
            scheduled_departure_time = ZonedDateTime(
                DateTime(flight.year, flight.month, flight.day, flight.hour, flight.minute),
                indexed_airports[flight.origin].time_zone
            )
            if haskey(indexed_airports, flight.destination)
                maybe_arrival_time = ZonedDateTime(
                    DateTime(flight.year, flight.month, flight.day, divrem(flight.scheduled_arrival_time, 100)...),
                    indexed_airports[flight.destination].time_zone
                )
                scheduled_arrival_time =
                    if maybe_arrival_time &lt; scheduled_departure_time
                        maybe_arrival_time + Day(1)
                    else
                        maybe_arrival_time
                    end
            else
                scheduled_arrival_time = missing
            end
            @name @&gt; flight |&gt;
            remove(_,
                :year,
                :month,
                :day,
                :hour,
                :minute,
                :time_hour,
                :departure_time,
                :arrival_time
            ) |&gt;
            transform(_,
                scheduled_departure_time = scheduled_departure_time,
                scheduled_arrival_time = scheduled_arrival_time,
                air_time = Minute(_.air_time),
                distance = _.distance * mi,
                departure_delay = Minute(_.departure_delay),
                arrival_delay = Minute(_.arrival_delay)
            )
        end;

julia&gt; flights =
        @&gt; flights_file |&gt;
        over(_, process_flight) |&gt;
        make_columns |&gt;
        rows;

julia&gt; Peek(flights)
Showing 4 of 336776 rows
| carrier | flight | origin | tail_number | destination |  scheduled_departure_time |    scheduled_arrival_time |    air_time | distance | departure_delay | arrival_delay |
| -------:| ------:| ------:| -----------:| -----------:| -------------------------:| -------------------------:| -----------:| --------:| ---------------:| -------------:|
|      UA |   1545 |    EWR |      N14228 |         IAH | 2013-01-01T05:15:00-05:00 | 2013-01-01T08:19:00-06:00 | 227 minutes |  1400 mi |       2 minutes |    11 minutes |
|      UA |   1714 |    LGA |      N24211 |         IAH | 2013-01-01T05:29:00-05:00 | 2013-01-01T08:30:00-06:00 | 227 minutes |  1416 mi |       4 minutes |    20 minutes |
|      AA |   1141 |    JFK |      N619AA |         MIA | 2013-01-01T05:40:00-05:00 | 2013-01-01T08:50:00-05:00 | 160 minutes |  1089 mi |       2 minutes |    33 minutes |
|      B6 |    725 |    JFK |      N804JB |         BQN | 2013-01-01T05:45:00-05:00 |                   missing | 183 minutes |  1576 mi |       -1 minute |   -18 minutes |</code></pre><p>Theoretically, the distances between two airports is always the same. Let&#39;s make sure this is also the case in our data. First, <a href="#LightQuery.order"><code>order</code></a> by <code>origin</code>, <code>destination</code>, and <code>distance</code>. Then <a href="#LightQuery.Group"><code>Group</code></a> <a href="#LightQuery.By"><code>By</code></a> the same variables.</p><pre><code class="language-julia-repl">julia&gt; paths_grouped =
        @name @&gt; flights |&gt;
        order(_, (:origin, :destination, :distance)) |&gt;
        Group(By(_, (:origin, :destination, :distance)));</code></pre><p>Each <code>Group</code> will contain a <a href="#LightQuery.key"><code>key</code></a> and <a href="#LightQuery.value"><code>value</code></a></p><pre><code class="language-julia-repl">julia&gt; path = first(paths_grouped);

julia&gt; key(path)
((origin, &quot;EWR&quot;), (destination, &quot;ALB&quot;), (distance, 143 mi))

julia&gt; value(path) |&gt; Peek
Showing 4 of 439 rows
| carrier | flight | origin | tail_number | destination |  scheduled_departure_time |    scheduled_arrival_time |   air_time | distance | departure_delay | arrival_delay |
| -------:| ------:| ------:| -----------:| -----------:| -------------------------:| -------------------------:| ----------:| --------:| ---------------:| -------------:|
|      EV |   4112 |    EWR |      N13538 |         ALB | 2013-01-01T13:17:00-05:00 | 2013-01-01T14:23:00-05:00 | 33 minutes |   143 mi |      -2 minutes |   -10 minutes |
|      EV |   3260 |    EWR |      N19554 |         ALB | 2013-01-01T16:21:00-05:00 | 2013-01-01T17:24:00-05:00 | 36 minutes |   143 mi |      34 minutes |    40 minutes |
|      EV |   4170 |    EWR |      N12540 |         ALB | 2013-01-01T20:04:00-05:00 | 2013-01-01T21:12:00-05:00 | 31 minutes |   143 mi |      52 minutes |    44 minutes |
|      EV |   4316 |    EWR |      N14153 |         ALB | 2013-01-02T13:27:00-05:00 | 2013-01-02T14:33:00-05:00 | 33 minutes |   143 mi |       5 minutes |   -14 minutes |</code></pre><p>At this point, we don&#39;t need any of the <code>value</code> data. All we need is the <code>key</code>.</p><pre><code class="language-julia-repl">julia&gt; paths =
        @&gt; paths_grouped |&gt;
        over(_, key) |&gt;
        make_columns |&gt;
        rows;

julia&gt; Peek(paths)
Showing 4 of 226 rows
| origin | destination | distance |
| ------:| -----------:| --------:|
|    EWR |         ALB |   143 mi |
|    EWR |         ANC |  3370 mi |
|    EWR |         ATL |   746 mi |
|    EWR |         AUS |  1504 mi |</code></pre><p>Notice the data is already sorted by <code>origin</code> and <code>destination</code>, so that for our second <code>Group</code>, we don&#39;t need to <code>order</code> first.</p><pre><code class="language-julia-repl">julia&gt; distinct_distances =
        @name @&gt; paths |&gt;
        Group(By(_, (:origin, :destination))) |&gt;
        over(_, @_ transform(key(_),
            number = length(value(_))
        ));

julia&gt; Peek(distinct_distances)
Showing at most 4 rows
| origin | destination | number |
| ------:| -----------:| ------:|
|    EWR |         ALB |      1 |
|    EWR |         ANC |      1 |
|    EWR |         ATL |      1 |
|    EWR |         AUS |      1 |</code></pre><p>Let&#39;s see <a href="#LightQuery.when"><code>when</code></a> there are multiple distances for the same path:</p><pre><code class="language-julia-repl">julia&gt; @&gt; distinct_distances |&gt;
        when(_, @_ _.number != 1) |&gt;
        Peek
Showing at most 4 rows
| origin | destination | number |
| ------:| -----------:| ------:|
|    EWR |         EGE |      2 |
|    JFK |         EGE |      2 |</code></pre><p>That&#39;s strange. What&#39;s up with the <code>EGE</code> airport? Let&#39;s take a <a href="#LightQuery.Peek"><code>Peek</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @&gt; flights |&gt;
        when(_, @_ _.destination == &quot;EGE&quot;) |&gt;
        Peek
Showing at most 4 rows
| carrier | flight | origin | tail_number | destination |  scheduled_departure_time |    scheduled_arrival_time |    air_time | distance | departure_delay | arrival_delay |
| -------:| ------:| ------:| -----------:| -----------:| -------------------------:| -------------------------:| -----------:| --------:| ---------------:| -------------:|
|      UA |   1597 |    EWR |      N27733 |         EGE | 2013-01-01T09:28:00-05:00 | 2013-01-01T12:20:00-07:00 | 287 minutes |  1726 mi |      -2 minutes |    13 minutes |
|      AA |    575 |    JFK |      N5DRAA |         EGE | 2013-01-01T17:00:00-05:00 | 2013-01-01T19:50:00-07:00 | 280 minutes |  1747 mi |      -5 minutes |     3 minutes |
|      UA |   1597 |    EWR |      N24702 |         EGE | 2013-01-02T09:28:00-05:00 | 2013-01-02T12:20:00-07:00 | 261 minutes |  1726 mi |        1 minute |     3 minutes |
|      AA |    575 |    JFK |      N631AA |         EGE | 2013-01-02T17:00:00-05:00 | 2013-01-02T19:50:00-07:00 | 260 minutes |  1747 mi |       5 minutes |    16 minutes |</code></pre><p>Looks (to me) like two different sources are reporting different info about the same flight.</p><h1><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h1><h2><a class="nav-anchor" id="Macros-1" href="#Macros-1">Macros</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.@_" href="#LightQuery.@_"><code>LightQuery.@_</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">macro _(body)</code></pre><p>Terser function syntax. The arguments are inside the body; the first argument is <code>_</code>, the second argument is <code>__</code>, etc.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; (@_ _ + 1)(1)
2

julia&gt; map((@_ __ - _), (1, 2), (2, 1))
(1, -1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/macros.jl#L51-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.@&gt;" href="#LightQuery.@&gt;"><code>LightQuery.@&gt;</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">macro &gt;(body)</code></pre><p>If body is in the form <code>body_ |&gt; tail_</code>, call <a href="#LightQuery.@_"><code>@_</code></a> on <code>tail</code>, and recur on <code>body</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @&gt; 0 |&gt; _ - 1 |&gt; abs
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/macros.jl#L78-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.@name" href="#LightQuery.@name"><code>LightQuery.@name</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">macro name(something)</code></pre><p>Replace raw symbols with typed names, and named tuples with typed named tuples. Typed names can be used with <code>getindex</code> (and will keep names) or as a function.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name :a
a

julia&gt; data = @name (a = 1, b = 2, c = 3)
((a, 1), (b, 2), (c, 3))

julia&gt; @name data[:a]
1

julia&gt; @name (:a)(data)
1

julia&gt; data.a
1

julia&gt; @name data[(:a, :b)]
((a, 1), (b, 2))

julia&gt; @name (1, 2)[(:a, :b)]
((a, 1), (b, 2))

julia&gt; @name (:a, :b)(data)
((a, 1), (b, 2))

julia&gt; @name (:a, :b)((1, 2))
((a, 1), (b, 2))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L65-L101">source</a></section><h2><a class="nav-anchor" id="Columns-1" href="#Columns-1">Columns</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.named_tuple" href="#LightQuery.named_tuple"><code>LightQuery.named_tuple</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">named_tuple(anything)</code></pre><p>Coerce <code>anything</code> to a typed named tuple. For performance with structs, define and <code>@inline</code> propertynames.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; data = @name ((a = 1, b = 2))
((a, 1), (b, 2))

julia&gt; struct MyType
            a::Int
            b::Int
        end

julia&gt; @inline Base.propertynames(::MyType) = (:a, :b);

julia&gt; named_tuple(MyType(1, 2))
((a, 1), (b, 2))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L107-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.rename" href="#LightQuery.rename"><code>LightQuery.rename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rename(data, assignments...)</code></pre><p>Rename <code>data</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name rename((a = 1, b = 2), c = :a)
((b, 2), (c, 1))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L184-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.transform" href="#LightQuery.transform"><code>LightQuery.transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transform(data, assignments...)</code></pre><p>Merge <code>assignments</code> into <code>data</code>, overwriting old values.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name transform((a = 1, b = 2), a = 3)
((b, 2), (a, 3))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L167-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.remove" href="#LightQuery.remove"><code>LightQuery.remove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">remove(data, names...)</code></pre><p>Remove <code>names</code> from <code>data</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name remove((a = 1, b = 2, c = 3), :b)
((a, 1), (c, 3))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L150-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.gather" href="#LightQuery.gather"><code>LightQuery.gather</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gather(data; assignments...)</code></pre><p>For each <code>key =&gt; value</code> pair in <code>assignments</code>, gather the names in <code>value</code> into a single <code>key</code>. Inverse of <a href="#LightQuery.spread"><code>spread</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name gather((a = 1, b = 2, c = 3), d = (:a, :c))
((b, 2), (d, ((a, 1), (c, 3))))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L209-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.spread" href="#LightQuery.spread"><code>LightQuery.spread</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spread(data, names...)</code></pre><p>Unnest nested <code>name</code> in <code>names</code>. Inverse of <a href="#LightQuery.gather"><code>gather</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name spread((b = 2, d = (a = 1, c = 3)), :d)
((b, 2), (a, 1), (c, 3))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L231-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.row_type" href="#LightQuery.row_type"><code>LightQuery.row_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">row_type(file::CSV.File)</code></pre><p>Get the <code>row_type</code> of a CSV <code>file</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; row_type(CSV.File(&quot;test.csv&quot;))
Tuple{Tuple{LightQuery.Name{:a},T} where T&lt;:Union{Missing, Int64},Tuple{LightQuery.Name{:b},T} where T&lt;:Union{Missing, Float64}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/pivot.jl#L120-L131">source</a></section><h2><a class="nav-anchor" id="Rows-1" href="#Rows-1">Rows</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.unzip" href="#LightQuery.unzip"><code>LightQuery.unzip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unzip(it, n)</code></pre><p>Unzip an iterator <code>it</code> which returns tuples of length <code>n</code>. Use <code>Val(n)</code> to guarantee type stability.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; unzip([(1, 1.0), (2, 2.0)], 2)
([1, 2], [1.0, 2.0])

julia&gt; unzip([(1, 1.0), (2, 2.0)], Val(2))
([1, 2], [1.0, 2.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/Unzip.jl#L60-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.Enumerated" href="#LightQuery.Enumerated"><code>LightQuery.Enumerated</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Enumerated{It}</code></pre><p>Relies on the fact that iteration states can be converted to indices; thus, you might have to define <code>LightQuery.state_to_index</code> for unrecognized types. Ignores some iterators like <code>Filter</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; collect(Enumerated(when([4, 3, 2, 1], iseven)))
2-element Array{Tuple{Int64,Int64},1}:
 (1, 4)
 (3, 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L22-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.over" href="#LightQuery.over"><code>LightQuery.over</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">over(it, call)</code></pre><p>Lazy <code>map</code> with argument order reversed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.indexed" href="#LightQuery.indexed"><code>LightQuery.indexed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">indexed(it, call)</code></pre><p>Index <code>it</code> by the results of <code>call</code>, with a default to <code>missing</code>. Relies on <a href="#LightQuery.Enumerated"><code>Enumerated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; result = @name indexed(
            [
                (item = &quot;b&quot;, index = 2),
                (item = &quot;a&quot;, index = 1)
            ],
            :index
        );

julia&gt; result[1]
((item, &quot;a&quot;), (index, 1))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L111-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.when" href="#LightQuery.when"><code>LightQuery.when</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">when(it, call)</code></pre><p>Lazy <code>filter</code> with argument order reversed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.order" href="#LightQuery.order"><code>LightQuery.order</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">order(it, call; keywords...)</code></pre><p>Generalized sort. <code>keywords</code> will be passed to <code>sort!</code>; see the documentation there for options. See <a href="#LightQuery.By"><code>By</code></a> for a way to explicitly mark that an object has been sorted. Relies on <a href="#LightQuery.Enumerated"><code>Enumerated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name order([
            (item = &quot;b&quot;, index = 2),
            (item = &quot;a&quot;, index = 1)
        ], :index)
2-element view(::Array{Tuple{Tuple{LightQuery.Name{:item},String},Tuple{LightQuery.Name{:index},Int64}},1}, [2, 1]) with eltype Tuple{Tuple{LightQuery.Name{:item},String},Tuple{LightQuery.Name{:index},Int64}}:
 ((item, &quot;a&quot;), (index, 1))
 ((item, &quot;b&quot;), (index, 2))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L55-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.By" href="#LightQuery.By"><code>LightQuery.By</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">By(it, call)</code></pre><p>Mark that <code>it</code> has been pre-sorted by <code>call</code>. For use with <a href="#LightQuery.Group"><code>Group</code></a> or <a href="#LightQuery.Join"><code>Join</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name By([
            (item = &quot;a&quot;, index = 1),
            (item = &quot;b&quot;, index = 2)
        ], :index);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L146-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.Group" href="#LightQuery.Group"><code>LightQuery.Group</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Group(it::By)</code></pre><p>Group consecutive keys in <code>it</code>. Requires a presorted object (see <a href="#LightQuery.By"><code>By</code></a>). Relies on <a href="#LightQuery.Enumerated"><code>Enumerated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name Group(By(
            [
                (item = &quot;a&quot;, group = 1),
                (item = &quot;b&quot;, group = 1),
                (item = &quot;c&quot;, group = 2),
                (item = &quot;d&quot;, group = 2)
            ],
            :group
        )) |&gt;
        collect
2-element Array{Pair{Int64,SubArray{Tuple{Tuple{LightQuery.Name{:item},String},Tuple{LightQuery.Name{:group},Int64}},1,Array{Tuple{Tuple{LightQuery.Name{:item},String},Tuple{LightQuery.Name{:group},Int64}},1},Tuple{UnitRange{Int64}},true}},1}:
 1 =&gt; [((item, &quot;a&quot;), (group, 1)), ((item, &quot;b&quot;), (group, 1))]
 2 =&gt; [((item, &quot;c&quot;), (group, 2)), ((item, &quot;d&quot;), (group, 2))]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L172-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.key" href="#LightQuery.key"><code>LightQuery.key</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">key(it)</code></pre><p>The <code>key</code> in a <code>key =&gt; value</code> pair.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L225-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.value" href="#LightQuery.value"><code>LightQuery.value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">value(it)</code></pre><p>The <code>value</code> in a <code>key =&gt; value</code> pair.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L233-L237">source</a><div><div><pre><code class="language-none">value(named::Tuple{LightQuery.Name,Any})</code></pre><p><code>named[2]</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/columns.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.Join" href="#LightQuery.Join"><code>LightQuery.Join</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Join(left::By, right::By)</code></pre><p>Find all pairs where <code>isequal(left.call(left.it), right.call(right.it))</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name Join(
            By(
                [
                    (left = &quot;a&quot;, index = 1),
                    (left = &quot;b&quot;, index = 2),
                    (left = &quot;e&quot;, index = 5),
                    (left = &quot;f&quot;, index = 6)
                ],
                :index
            ),
            By(
                [
                    (right = &quot;a&quot;, index = 1),
                    (right = &quot;c&quot;, index = 3),
                    (right = &quot;d&quot;, index = 4),
                    (right = &quot;e&quot;, index = 6)
                ],
                :index
            )
        ) |&gt;
        collect
6-element Array{Pair{Union{Missing, Tuple{Tuple{Name{:left},String},Tuple{Name{:index},Int64}}},Union{Missing, Tuple{Tuple{Name{:right},String},Tuple{Name{:index},Int64}}}},1}:
 ((left, &quot;a&quot;), (index, 1)) =&gt; ((right, &quot;a&quot;), (index, 1))
 ((left, &quot;b&quot;), (index, 2)) =&gt; missing
                   missing =&gt; ((right, &quot;c&quot;), (index, 3))
                   missing =&gt; ((right, &quot;d&quot;), (index, 4))
 ((left, &quot;e&quot;), (index, 5)) =&gt; missing
 ((left, &quot;f&quot;), (index, 6)) =&gt; ((right, &quot;e&quot;), (index, 6))</code></pre><p>Assumes <code>left</code> and <code>right</code> are both strictly sorted (no repeats). If there are repeats, <a href="#LightQuery.Group"><code>Group</code></a> first. For other join flavors, combine with <a href="#LightQuery.when"><code>when</code></a>. Make sure to annotate with <a href="#LightQuery.Length"><code>Length</code></a> if you know it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L253-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.Length" href="#LightQuery.Length"><code>LightQuery.Length</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Length(it, length)</code></pre><p>Allow optimizations based on length. Especially useful after <a href="#LightQuery.Join"><code>Join</code></a> and before <a href="#LightQuery.make_columns"><code>make_columns</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @&gt; Filter(iseven, 1:4) |&gt;
        Length(_, 2) |&gt;
        collect
2-element Array{Int64,1}:
 2
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/rows.jl#L334-L349">source</a></section><h2><a class="nav-anchor" id="Pivot-1" href="#Pivot-1">Pivot</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.item_names" href="#LightQuery.item_names"><code>LightQuery.item_names</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">item_names(it)</code></pre><p>Find names of items in <code>it</code>. Used in <a href="#LightQuery.Peek"><code>Peek</code></a> and <a href="#LightQuery.make_columns"><code>make_columns</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name item_names([(a = 1, b = 1.0), (a = 2, b = 2.0)])
(a, b)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/pivot.jl#L4-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.rows" href="#LightQuery.rows"><code>LightQuery.rows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rows(it)</code></pre><p>Iterator over <code>rows</code> of a <code>NamedTuple</code> of arrays. Always lazy. Inverse of <a href="#LightQuery.columns"><code>columns</code></a>. See <a href="#LightQuery.Peek"><code>Peek</code></a> for a way to view.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name collect(rows((a = [1, 2], b = [1.0, 2.0])))
2-element Array{Tuple{Tuple{LightQuery.Name{:a},Int64},Tuple{LightQuery.Name{:b},Float64}},1}:
 ((a, 1), (b, 1.0))
 ((a, 2), (b, 2.0))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/pivot.jl#L19-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.Peek" href="#LightQuery.Peek"><code>LightQuery.Peek</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Peek(it; max_rows = 4)</code></pre><p>Get a peek of an iterator which returns items with <code>propertynames</code>. Will show no more than <code>max_rows</code>. Relies on <a href="#LightQuery.item_names"><code>item_names</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name Peek(rows((a = 1:5, b = 5:-1:1)))
Showing 4 of 5 rows
|   a |   b |
| ---:| ---:|
|   1 |   5 |
|   2 |   4 |
|   3 |   3 |
|   4 |   2 |</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/pivot.jl#L41-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.columns" href="#LightQuery.columns"><code>LightQuery.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">columns(it)</code></pre><p>Inverse of <a href="#LightQuery.rows"><code>rows</code></a>. Always lazy, see <a href="#LightQuery.make_columns"><code>make_columns</code></a> for eager version.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name columns(rows((a = [1, 2], b = [1.0, 2.0])))
((a, [1, 2]), (b, [1.0, 2.0]))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/pivot.jl#L74-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightQuery.make_columns" href="#LightQuery.make_columns"><code>LightQuery.make_columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">make_columns(it)</code></pre><p>Collect into columns. Always eager, see <a href="#LightQuery.columns"><code>columns</code></a> for lazy version. Relies on <a href="#LightQuery.item_names"><code>item_names</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using LightQuery

julia&gt; @name make_columns([(a = 1, b = 1.0), (a = 2, b = 2.0)])
((a, [1, 2]), (b, [1.0, 2.0]))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LightQuery.jl/blob/102a987dce843275f13f6fc67aee410b18298ad9/src/pivot.jl#L92-L103">source</a></section><footer><hr/></footer></article></body></html>
